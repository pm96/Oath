{"version":3,"names":["_firestore","require","_firebaseConfig","_habitStreaks","_dateUtils","_errorHandling","_collections","_habitStreakSchemas","StreakService","exports","_classCallCheck2","default","_createClass2","key","value","_calculateStreak","_asyncToGenerator2","habitId","userId","_this","Error","retryWithBackoff","runTransaction","db","_ref2","transaction","streakId","generateStreakId","streaksCollection","getHabitStreaksCollection","streakDocRef","doc","streakDoc","get","completionsCollection","getHabitCompletionsCollection","completionsQuery","query","where","completionsSnapshot","getDocs","completions","docs","map","transformFirestoreToCompletion","id","data","sort","a","b","completedAt","toMillis","calculatedStreak","calculateStreakFromCompletions","existingStreak","exists","transformFirestoreToStreak","updatedStreak","mergeStreakData","streakData","transformStreakToFirestore","set","_x3","apply","arguments","error","message","getUserFriendlyErrorMessage","calculateStreak","_x","_x2","_recordCompletion","completion","userTimezone","timezone","getUserTimezone","completionDateString","timestampToDateString","currentDateString","getCurrentDateString","_ref4","existingCompletionsQuery","existingSnapshot","existingCompletions","filter","comp","compDateString","length","completionData","notes","difficulty","createdAt","serverTimestamp","completionRef","newCompletion","Object","assign","_x5","recordCompletion","_x4","_useStreakFreeze","missedDate","_ref6","streak","validateUserOwnership","freezesAvailable","freezesUsed","protectedCompletion","Timestamp","fromDate","parseDateString","_x9","useStreakFreeze","_x6","_x7","_x8","_getHabitCalendar","days","_this2","endDate","startDate","formatDateToString","Date","now","getHabitStreak","dateRange","generateDateRange","calendarDays","date","find","isInStreak","isDateInCurrentStreak","completed","isToday","completionTime","toDate","toLocaleTimeString","undefined","getHabitCalendar","_x0","_x1","_x10","_x11","_checkMilestones","newMilestones","existingMilestoneDays","milestones","m","milestoneDay","MILESTONE_DAYS","currentStreak","includes","milestone","achievedAt","celebrated","push","concat","_toConsumableArray2","_ref8","_x13","checkMilestones","_x12","_getHabitStreak","getDoc","validateStreakDocument","_x14","_x15","_initializeHabitStreak","currentDate","initialStreak","bestStreak","lastCompletionDate","streakStartDate","_ref9","_x18","initializeHabitStreak","_x16","_x17","_resetStreak","resetDate","_ref1","resetStreak","_x22","_x19","_x20","_x21","_completions$","completionDates","uniqueDates","Set","today","yesterday","i","previousDate","areConsecutiveDays","tempStreak","Math","max","calculated","existing","streakStart","checkDate","streakEnd","setDate","getDate","streakService"],"sources":["streakService.ts"],"sourcesContent":["import {\n    doc,\n    getDoc,\n    getDocs,\n    query,\n    runTransaction,\n    serverTimestamp,\n    Timestamp,\n    where,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebaseConfig\";\nimport {\n    CalendarDay,\n    HabitCompletion,\n    HabitStreak,\n    MILESTONE_DAYS,\n    StreakMilestone,\n} from \"../../types/habit-streaks\";\nimport {\n    areConsecutiveDays,\n    formatDateToString,\n    generateDateRange,\n    getCurrentDateString,\n    getUserTimezone,\n    isToday,\n    parseDateString,\n    timestampToDateString,\n} from \"../../utils/dateUtils\";\nimport {\n    getUserFriendlyErrorMessage,\n    retryWithBackoff,\n} from \"../../utils/errorHandling\";\nimport {\n    getHabitCompletionsCollection,\n    getHabitStreaksCollection,\n} from \"./collections\";\nimport { StreakService as IStreakService } from \"./habitStreakInterfaces\";\nimport {\n    generateStreakId,\n    transformFirestoreToCompletion,\n    transformFirestoreToStreak,\n    transformStreakToFirestore,\n    validateStreakDocument,\n    validateUserOwnership,\n} from \"./habitStreakSchemas\";\n\n/**\n * StreakService Implementation\n *\n * Handles all streak calculation, tracking, and management functionality\n * with timezone awareness and data integrity protection.\n */\nexport class StreakService implements IStreakService {\n    /**\n     * Calculate and update streak information for a habit\n     * Requirements: 1.1, 1.2, 1.3\n     */\n    async calculateStreak(habitId: string, userId: string): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Get current streak data\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    // Get all completions for this habit\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", habitId),\n                        where(\"userId\", \"==\", userId),\n                    );\n                    const completionsSnapshot = await getDocs(completionsQuery);\n\n                    // Transform completions and sort by date\n                    const completions = completionsSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .sort(\n                            (a, b) => a.completedAt.toMillis() - b.completedAt.toMillis(),\n                        );\n\n                    // Calculate streak from completions\n                    const calculatedStreak = this.calculateStreakFromCompletions(\n                        completions,\n                        habitId,\n                        userId,\n                    );\n\n                    // Merge with existing data if available\n                    let existingStreak: HabitStreak | null = null;\n                    if (streakDoc.exists()) {\n                        existingStreak = transformFirestoreToStreak(streakDoc.data());\n                    }\n\n                    const updatedStreak = this.mergeStreakData(\n                        calculatedStreak,\n                        existingStreak,\n                    );\n\n                    // Save updated streak\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return updatedStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to calculate streak: ${message}`);\n        }\n    }\n\n    /**\n     * Record a new habit completion and update streak\n     * Requirements: 5.1, 12.1\n     */\n    async recordCompletion(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<HabitCompletion> {\n        if (!completion.habitId || !completion.userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        // Validate timezone-aware completion\n        const userTimezone = completion.timezone || getUserTimezone();\n        const completionDateString = timestampToDateString(\n            completion.completedAt,\n            userTimezone,\n        );\n        const currentDateString = getCurrentDateString(userTimezone);\n\n        // Ensure completion is for current day or earlier (prevent future completions)\n        if (completionDateString > currentDateString) {\n            throw new Error(\"Cannot record completions for future dates\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Check for existing completion on the same date\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const existingCompletionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", completion.habitId),\n                        where(\"userId\", \"==\", completion.userId),\n                    );\n                    const existingSnapshot = await getDocs(existingCompletionsQuery);\n\n                    const existingCompletions = existingSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .filter((comp) => {\n                            const compDateString = timestampToDateString(\n                                comp.completedAt,\n                                userTimezone,\n                            );\n                            return compDateString === completionDateString;\n                        });\n\n                    if (existingCompletions.length > 0) {\n                        throw new Error(\"Habit already completed for this date\");\n                    }\n\n                    // Create completion record\n                    const completionData = {\n                        habitId: completion.habitId,\n                        userId: completion.userId,\n                        completedAt: completion.completedAt,\n                        timezone: userTimezone,\n                        notes: completion.notes,\n                        difficulty: completion.difficulty,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, completionData);\n\n                    const newCompletion: HabitCompletion = {\n                        id: completionRef.id,\n                        ...completion,\n                        timezone: userTimezone,\n                    };\n\n                    return newCompletion;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to record completion: ${message}`);\n        }\n    }\n\n    /**\n     * Use a streak freeze to protect from a missed day\n     * Requirements: 4.1, 4.2, 4.5\n     */\n    async useStreakFreeze(\n        habitId: string,\n        userId: string,\n        missedDate: string,\n    ): Promise<boolean> {\n        if (!habitId || !userId || !missedDate) {\n            throw new Error(\"Habit ID, User ID, and missed date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    // Check if freeze is available\n                    if (streak.freezesAvailable <= 0) {\n                        return false;\n                    }\n\n                    // Use the freeze\n                    const updatedStreak: HabitStreak = {\n                        ...streak,\n                        freezesAvailable: streak.freezesAvailable - 1,\n                        freezesUsed: streak.freezesUsed + 1,\n                    };\n\n                    // Create a \"protected\" completion record for the missed date\n                    const protectedCompletion = {\n                        habitId,\n                        userId,\n                        completedAt: Timestamp.fromDate(parseDateString(missedDate)),\n                        timezone: getUserTimezone(),\n                        notes: \"Protected by streak freeze\",\n                        difficulty: \"easy\" as const,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, protectedCompletion);\n\n                    // Update streak data\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return true;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to use streak freeze: ${message}`);\n        }\n    }\n\n    /**\n     * Get calendar data for a habit showing completion status\n     * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5\n     */\n    async getHabitCalendar(\n        habitId: string,\n        userId: string,\n        days: number,\n        timezone: string,\n    ): Promise<CalendarDay[]> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                // Get date range for calendar\n                const endDate = getCurrentDateString(timezone);\n                const startDate = formatDateToString(\n                    new Date(Date.now() - (days - 1) * 24 * 60 * 60 * 1000),\n                    timezone,\n                );\n\n                // Get completions for the date range\n                const completionsCollection = getHabitCompletionsCollection();\n                const completionsQuery = query(\n                    completionsCollection,\n                    where(\"habitId\", \"==\", habitId),\n                    where(\"userId\", \"==\", userId),\n                );\n                const completionsSnapshot = await getDocs(completionsQuery);\n\n                const completions = completionsSnapshot.docs\n                    .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                    .filter((completion) => {\n                        const compDateString = timestampToDateString(\n                            completion.completedAt,\n                            timezone,\n                        );\n                        return compDateString >= startDate && compDateString <= endDate;\n                    });\n\n                // Get streak data for highlighting\n                const streak = await this.getHabitStreak(habitId, userId);\n\n                // Generate calendar days\n                const dateRange = generateDateRange(startDate, endDate);\n                const calendarDays: CalendarDay[] = dateRange.map((date) => {\n                    const completion = completions.find(\n                        (comp) =>\n                            timestampToDateString(comp.completedAt, timezone) === date,\n                    );\n\n                    const isInStreak = this.isDateInCurrentStreak(date, streak);\n\n                    return {\n                        date,\n                        completed: !!completion,\n                        isToday: isToday(date, timezone),\n                        isInStreak,\n                        completionTime: completion\n                            ? completion.completedAt.toDate().toLocaleTimeString()\n                            : undefined,\n                        notes: completion?.notes,\n                    };\n                });\n\n                return calendarDays;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit calendar: ${message}`);\n        }\n    }\n\n    /**\n     * Check for new milestones and return any that should be celebrated\n     * Requirements: 3.1, 3.2, 4.4\n     */\n    async checkMilestones(streak: HabitStreak): Promise<StreakMilestone[]> {\n        const newMilestones: StreakMilestone[] = [];\n        const existingMilestoneDays = streak.milestones.map((m) => m.days);\n\n        for (const milestoneDay of MILESTONE_DAYS) {\n            if (\n                streak.currentStreak >= milestoneDay &&\n                !existingMilestoneDays.includes(milestoneDay)\n            ) {\n                const milestone: StreakMilestone = {\n                    days: milestoneDay,\n                    achievedAt: Timestamp.now(),\n                    celebrated: false,\n                };\n                newMilestones.push(milestone);\n\n                // Award streak freeze for 30-day milestones\n                if (milestoneDay === 30) {\n                    streak.freezesAvailable += 1;\n                }\n            }\n        }\n\n        // Update streak with new milestones\n        if (newMilestones.length > 0) {\n            const updatedStreak: HabitStreak = {\n                ...streak,\n                milestones: [...streak.milestones, ...newMilestones],\n            };\n\n            const streakId = generateStreakId(streak.userId, streak.habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(updatedStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n        }\n\n        return newMilestones;\n    }\n\n    /**\n     * Get streak information for a specific habit\n     */\n    async getHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak | null> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakDoc = await getDoc(streakDocRef);\n\n            if (!streakDoc.exists()) {\n                return null;\n            }\n\n            const streakData = streakDoc.data();\n            if (!validateStreakDocument(streakData)) {\n                throw new Error(\"Invalid streak data format\");\n            }\n\n            return transformFirestoreToStreak(streakData);\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Initialize streak data for a new habit\n     */\n    async initializeHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        const currentDate = getCurrentDateString(getUserTimezone());\n        const initialStreak: HabitStreak = {\n            habitId,\n            userId,\n            currentStreak: 0,\n            bestStreak: 0,\n            lastCompletionDate: \"\",\n            streakStartDate: currentDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(initialStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n\n            return initialStreak;\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to initialize habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Reset a streak (used when streak is broken and no freeze available)\n     * Requirements: 1.2\n     */\n    async resetStreak(\n        habitId: string,\n        userId: string,\n        resetDate: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId || !resetDate) {\n            throw new Error(\"Habit ID, User ID, and reset date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    const resetStreak: HabitStreak = {\n                        ...streak,\n                        currentStreak: 0,\n                        lastCompletionDate: \"\",\n                        streakStartDate: resetDate,\n                    };\n\n                    const streakData = transformStreakToFirestore(resetStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return resetStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to reset streak: ${message}`);\n        }\n    }\n\n    // Private helper methods\n\n    /**\n     * Calculate streak from completion records\n     */\n    private calculateStreakFromCompletions(\n        completions: HabitCompletion[],\n        habitId: string,\n        userId: string,\n    ): HabitStreak {\n        if (completions.length === 0) {\n            return {\n                habitId,\n                userId,\n                currentStreak: 0,\n                bestStreak: 0,\n                lastCompletionDate: \"\",\n                streakStartDate: getCurrentDateString(getUserTimezone()),\n                freezesAvailable: 0,\n                freezesUsed: 0,\n                milestones: [],\n            };\n        }\n\n        const timezone = completions[0]?.timezone || getUserTimezone();\n        const completionDates = completions.map((comp) =>\n            timestampToDateString(comp.completedAt, timezone),\n        );\n\n        // Remove duplicates and sort\n        const uniqueDates = [...new Set(completionDates)].sort();\n\n        // Calculate current streak (from most recent completion backwards)\n        let currentStreak = 0;\n        let streakStartDate = \"\";\n        const today = getCurrentDateString(timezone);\n        const yesterday = formatDateToString(\n            new Date(Date.now() - 24 * 60 * 60 * 1000),\n            timezone,\n        );\n\n        // Check if there's a completion today or yesterday to start counting\n        const lastCompletionDate = uniqueDates[uniqueDates.length - 1];\n        if (lastCompletionDate === today || lastCompletionDate === yesterday) {\n            currentStreak = 1;\n            streakStartDate = lastCompletionDate;\n\n            // Count backwards for consecutive days\n            for (let i = uniqueDates.length - 2; i >= 0; i--) {\n                const currentDate = uniqueDates[i + 1];\n                const previousDate = uniqueDates[i];\n\n                if (areConsecutiveDays(previousDate, currentDate)) {\n                    currentStreak++;\n                    streakStartDate = previousDate;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Calculate best streak (longest consecutive sequence)\n        let bestStreak = 0;\n        let tempStreak = 1;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            if (areConsecutiveDays(uniqueDates[i - 1], uniqueDates[i])) {\n                tempStreak++;\n            } else {\n                bestStreak = Math.max(bestStreak, tempStreak);\n                tempStreak = 1;\n            }\n        }\n        bestStreak = Math.max(bestStreak, tempStreak, currentStreak);\n\n        return {\n            habitId,\n            userId,\n            currentStreak,\n            bestStreak,\n            lastCompletionDate,\n            streakStartDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n    }\n\n    /**\n     * Merge calculated streak with existing streak data\n     */\n    private mergeStreakData(\n        calculated: HabitStreak,\n        existing: HabitStreak | null,\n    ): HabitStreak {\n        if (!existing) {\n            return calculated;\n        }\n\n        return {\n            ...calculated,\n            freezesAvailable: existing.freezesAvailable,\n            freezesUsed: existing.freezesUsed,\n            milestones: existing.milestones,\n            // Ensure best streak never decreases\n            bestStreak: Math.max(calculated.bestStreak, existing.bestStreak),\n        };\n    }\n\n    /**\n     * Check if a date is within the current streak period\n     */\n    private isDateInCurrentStreak(\n        date: string,\n        streak: HabitStreak | null,\n    ): boolean {\n        if (!streak || streak.currentStreak === 0 || !streak.streakStartDate) {\n            return false;\n        }\n\n        const streakStart = parseDateString(streak.streakStartDate);\n        const checkDate = parseDateString(date);\n        const streakEnd = new Date(streakStart);\n        streakEnd.setDate(streakEnd.getDate() + streak.currentStreak - 1);\n\n        return checkDate >= streakStart && checkDate <= streakEnd;\n    }\n}\n\n// Export singleton instance\nexport const streakService = new StreakService();\n"],"mappings":"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","ignoreList":[]}