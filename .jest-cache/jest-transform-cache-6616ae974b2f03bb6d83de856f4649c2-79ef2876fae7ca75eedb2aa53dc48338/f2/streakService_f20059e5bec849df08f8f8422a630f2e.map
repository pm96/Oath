{"version":3,"names":["_firestore","require","_firebaseConfig","_habitStreaks","_dateUtils","_errorHandling","_collections","_habitStreakSchemas","StreakService","exports","_classCallCheck2","default","_createClass2","key","value","_calculateStreak","_asyncToGenerator2","habitId","userId","_this","Error","retryWithBackoff","runTransaction","db","_ref2","transaction","streakId","generateStreakId","streaksCollection","getHabitStreaksCollection","streakDocRef","doc","streakDoc","get","completionsCollection","getHabitCompletionsCollection","completionsQuery","query","where","completionsSnapshot","getDocs","completions","docs","map","transformFirestoreToCompletion","id","data","sort","a","b","completedAt","toMillis","calculatedStreak","calculateStreakFromCompletions","existingStreak","exists","transformFirestoreToStreak","updatedStreak","mergeStreakData","integrityCheck","dataIntegrityService","verifyStreakIntegrity","isValid","console","warn","errors","finalStreak","correctedData","streakData","transformStreakToFirestore","set","_x3","apply","arguments","error","message","getUserFriendlyErrorMessage","calculateStreak","_x","_x2","_recordCompletion","completion","userTimezone","timezone","getUserTimezone","completionDateString","timestampToDateString","currentDateString","getCurrentDateString","_ref4","existingCompletionsQuery","existingSnapshot","existingCompletions","filter","comp","compDateString","length","completionData","notes","difficulty","createdAt","serverTimestamp","completionRef","newCompletion","Object","assign","syncService","queueOperation","type","action","_x5","recordCompletion","_x4","_recordCompletionWithMilestoneCheck","recordedCompletion","newMilestones","checkMilestones","recordCompletionWithMilestoneCheck","_x6","_useStreakFreeze","missedDate","_ref6","streak","validateUserOwnership","freezesAvailable","freezesUsed","protectedCompletion","Timestamp","fromDate","parseDateString","_x0","useStreakFreeze","_x7","_x8","_x9","_getHabitCalendar","days","_this2","endDate","startDate","formatDateToString","Date","now","getHabitStreak","dateRange","generateDateRange","calendarDays","date","find","isInStreak","isDateInCurrentStreak","completed","isToday","completionTime","toDate","toLocaleTimeString","undefined","getHabitCalendar","_x1","_x10","_x11","_x12","_checkMilestones","existingMilestoneDays","milestones","m","milestoneDay","MILESTONE_DAYS","currentStreak","includes","milestone","achievedAt","celebrated","push","concat","_toConsumableArray2","_ref8","_x14","habitName","getHabitName","log","_x13","_getHabitStreak","getDoc","validateStreakDocument","_x15","_x16","_initializeHabitStreak","currentDate","initialStreak","bestStreak","lastCompletionDate","streakStartDate","_ref9","_x19","initializeHabitStreak","_x17","_x18","_resetStreak","resetDate","_this3","_ref1","resetStreak","_x23","_x20","_x21","_x22","_completions$","completionDates","uniqueDates","Array","from","Set","today","yesterday","i","previousDate","areConsecutiveDays","tempStreak","Math","max","calculated","existing","_getHabitName","goalRef","goalDoc","goalData","description","_x24","streakStart","checkDate","streakEnd","setDate","getDate","streakService"],"sources":["streakService.ts"],"sourcesContent":["import {\n    doc,\n    getDoc,\n    getDocs,\n    query,\n    runTransaction,\n    serverTimestamp,\n    Timestamp,\n    where,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebaseConfig\";\nimport {\n    CalendarDay,\n    HabitCompletion,\n    HabitStreak,\n    MILESTONE_DAYS,\n    StreakMilestone,\n} from \"../../types/habit-streaks\";\nimport {\n    areConsecutiveDays,\n    formatDateToString,\n    generateDateRange,\n    getCurrentDateString,\n    getUserTimezone,\n    isToday,\n    parseDateString,\n    timestampToDateString,\n} from \"../../utils/dateUtils\";\nimport {\n    getUserFriendlyErrorMessage,\n    retryWithBackoff,\n} from \"../../utils/errorHandling\";\nimport {\n    getHabitCompletionsCollection,\n    getHabitStreaksCollection,\n} from \"./collections\";\nimport { StreakService as IStreakService } from \"./habitStreakInterfaces\";\nimport {\n    generateStreakId,\n    transformFirestoreToCompletion,\n    transformFirestoreToStreak,\n    transformStreakToFirestore,\n    validateStreakDocument,\n    validateUserOwnership,\n} from \"./habitStreakSchemas\";\n\n/**\n * StreakService Implementation\n *\n * Handles all streak calculation, tracking, and management functionality\n * with timezone awareness and data integrity protection.\n */\nexport class StreakService implements IStreakService {\n    /**\n     * Calculate and update streak information for a habit\n     * Requirements: 1.1, 1.2, 1.3, 10.2, 12.4\n     */\n    async calculateStreak(habitId: string, userId: string): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Get current streak data\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    // Get all completions for this habit\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", habitId),\n                        where(\"userId\", \"==\", userId),\n                    );\n                    const completionsSnapshot = await getDocs(completionsQuery);\n\n                    // Transform completions and sort by date\n                    const completions = completionsSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .sort(\n                            (a, b) => a.completedAt.toMillis() - b.completedAt.toMillis(),\n                        );\n\n                    // Calculate streak from completions\n                    const calculatedStreak = this.calculateStreakFromCompletions(\n                        completions,\n                        habitId,\n                        userId,\n                    );\n\n                    // Merge with existing data if available\n                    let existingStreak: HabitStreak | null = null;\n                    if (streakDoc.exists()) {\n                        existingStreak = transformFirestoreToStreak(streakDoc.data());\n                    }\n\n                    const updatedStreak = this.mergeStreakData(\n                        calculatedStreak,\n                        existingStreak,\n                    );\n\n                    // Verify data integrity before saving\n                    const integrityCheck =\n                        await dataIntegrityService.verifyStreakIntegrity(\n                            habitId,\n                            userId,\n                            updatedStreak,\n                        );\n\n                    if (!integrityCheck.isValid) {\n                        console.warn(\n                            \"Streak integrity issues detected:\",\n                            integrityCheck.errors,\n                        );\n                        // Use corrected data if available\n                        const finalStreak = integrityCheck.correctedData || updatedStreak;\n\n                        // Save corrected streak\n                        const streakData = transformStreakToFirestore(finalStreak);\n                        transaction.set(streakDocRef, streakData);\n\n                        return finalStreak;\n                    }\n\n                    // Save updated streak\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return updatedStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to calculate streak: ${message}`);\n        }\n    }\n\n    /**\n     * Record a new habit completion and update streak\n     * Requirements: 5.1, 12.1, 10.4\n     */\n    async recordCompletion(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<HabitCompletion> {\n        if (!completion.habitId || !completion.userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        // Validate timezone-aware completion\n        const userTimezone = completion.timezone || getUserTimezone();\n        const completionDateString = timestampToDateString(\n            completion.completedAt,\n            userTimezone,\n        );\n        const currentDateString = getCurrentDateString(userTimezone);\n\n        // Ensure completion is for current day or earlier (prevent future completions)\n        if (completionDateString > currentDateString) {\n            throw new Error(\"Cannot record completions for future dates\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Check for existing completion on the same date\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const existingCompletionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", completion.habitId),\n                        where(\"userId\", \"==\", completion.userId),\n                    );\n                    const existingSnapshot = await getDocs(existingCompletionsQuery);\n\n                    const existingCompletions = existingSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .filter((comp) => {\n                            const compDateString = timestampToDateString(\n                                comp.completedAt,\n                                userTimezone,\n                            );\n                            return compDateString === completionDateString;\n                        });\n\n                    if (existingCompletions.length > 0) {\n                        throw new Error(\"Habit already completed for this date\");\n                    }\n\n                    // Create completion record with metadata\n                    const completionData = {\n                        habitId: completion.habitId,\n                        userId: completion.userId,\n                        completedAt: completion.completedAt,\n                        timezone: userTimezone,\n                        notes: completion.notes || \"\",\n                        difficulty: completion.difficulty,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, completionData);\n\n                    const newCompletion: HabitCompletion = {\n                        id: completionRef.id,\n                        ...completion,\n                        timezone: userTimezone,\n                    };\n\n                    // Queue for sync to other devices\n                    await syncService.queueOperation({\n                        type: \"completion\",\n                        action: \"create\",\n                        data: completionData,\n                        userId: completion.userId,\n                        habitId: completion.habitId,\n                    });\n\n                    return newCompletion;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to record completion: ${message}`);\n        }\n    }\n\n    /**\n     * Record completion and check for milestone achievements\n     * This is the main method that should be called when a user completes a habit\n     * Requirements: 3.1, 3.2, 5.1\n     */\n    async recordCompletionWithMilestoneCheck(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<{\n        completion: HabitCompletion;\n        newMilestones: StreakMilestone[];\n        updatedStreak: HabitStreak;\n    }> {\n        // Record the completion\n        const recordedCompletion = await this.recordCompletion(completion);\n\n        // Recalculate streak with the new completion\n        const updatedStreak = await this.calculateStreak(\n            completion.habitId,\n            completion.userId,\n        );\n\n        // Check for new milestones\n        const newMilestones = await this.checkMilestones(updatedStreak);\n\n        return {\n            completion: recordedCompletion,\n            newMilestones,\n            updatedStreak,\n        };\n    }\n\n    /**\n     * Use a streak freeze to protect from a missed day\n     * Requirements: 4.1, 4.2, 4.5\n     */\n    async useStreakFreeze(\n        habitId: string,\n        userId: string,\n        missedDate: string,\n    ): Promise<boolean> {\n        if (!habitId || !userId || !missedDate) {\n            throw new Error(\"Habit ID, User ID, and missed date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    // Check if freeze is available\n                    if (streak.freezesAvailable <= 0) {\n                        return false;\n                    }\n\n                    // Use the freeze\n                    const updatedStreak: HabitStreak = {\n                        ...streak,\n                        freezesAvailable: streak.freezesAvailable - 1,\n                        freezesUsed: streak.freezesUsed + 1,\n                    };\n\n                    // Create a \"protected\" completion record for the missed date\n                    const protectedCompletion = {\n                        habitId,\n                        userId,\n                        completedAt: Timestamp.fromDate(parseDateString(missedDate)),\n                        timezone: getUserTimezone(),\n                        notes: \"Protected by streak freeze\",\n                        difficulty: \"easy\" as const,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, protectedCompletion);\n\n                    // Update streak data\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return true;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to use streak freeze: ${message}`);\n        }\n    }\n\n    /**\n     * Get calendar data for a habit showing completion status\n     * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5\n     */\n    async getHabitCalendar(\n        habitId: string,\n        userId: string,\n        days: number,\n        timezone: string,\n    ): Promise<CalendarDay[]> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                // Get date range for calendar\n                const endDate = getCurrentDateString(timezone);\n                const startDate = formatDateToString(\n                    new Date(Date.now() - (days - 1) * 24 * 60 * 60 * 1000),\n                    timezone,\n                );\n\n                // Get completions for the date range\n                const completionsCollection = getHabitCompletionsCollection();\n                const completionsQuery = query(\n                    completionsCollection,\n                    where(\"habitId\", \"==\", habitId),\n                    where(\"userId\", \"==\", userId),\n                );\n                const completionsSnapshot = await getDocs(completionsQuery);\n\n                const completions = completionsSnapshot.docs\n                    .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                    .filter((completion) => {\n                        const compDateString = timestampToDateString(\n                            completion.completedAt,\n                            timezone,\n                        );\n                        return compDateString >= startDate && compDateString <= endDate;\n                    });\n\n                // Get streak data for highlighting\n                const streak = await this.getHabitStreak(habitId, userId);\n\n                // Generate calendar days\n                const dateRange = generateDateRange(startDate, endDate);\n                const calendarDays: CalendarDay[] = dateRange.map((date) => {\n                    const completion = completions.find(\n                        (comp) =>\n                            timestampToDateString(comp.completedAt, timezone) === date,\n                    );\n\n                    const isInStreak = this.isDateInCurrentStreak(date, streak);\n\n                    return {\n                        date,\n                        completed: !!completion,\n                        isToday: isToday(date, timezone),\n                        isInStreak,\n                        completionTime: completion\n                            ? completion.completedAt.toDate().toLocaleTimeString()\n                            : undefined,\n                        notes: completion?.notes,\n                    };\n                });\n\n                return calendarDays;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit calendar: ${message}`);\n        }\n    }\n\n    /**\n     * Check for new milestones and return any that should be celebrated\n     * Requirements: 3.1, 3.2, 4.4, 11.2\n     */\n    async checkMilestones(streak: HabitStreak): Promise<StreakMilestone[]> {\n        const newMilestones: StreakMilestone[] = [];\n        const existingMilestoneDays = streak.milestones.map((m) => m.days);\n\n        for (const milestoneDay of MILESTONE_DAYS) {\n            if (\n                streak.currentStreak >= milestoneDay &&\n                !existingMilestoneDays.includes(milestoneDay)\n            ) {\n                const milestone: StreakMilestone = {\n                    days: milestoneDay,\n                    achievedAt: Timestamp.now(),\n                    celebrated: false,\n                };\n                newMilestones.push(milestone);\n\n                // Award streak freeze for 30-day milestones (Requirement 4.4)\n                if (milestoneDay === 30) {\n                    streak.freezesAvailable += 1;\n                }\n            }\n        }\n\n        // Update streak with new milestones\n        if (newMilestones.length > 0) {\n            const updatedStreak: HabitStreak = {\n                ...streak,\n                milestones: [...streak.milestones, ...newMilestones],\n                // Update freezes if 30-day milestone was achieved\n                freezesAvailable: streak.freezesAvailable,\n            };\n\n            const streakId = generateStreakId(streak.userId, streak.habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(updatedStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n\n            // Send milestone notifications for new milestones\n            // Requirements: 11.2\n            for (const milestone of newMilestones) {\n                try {\n                    const habitName = await this.getHabitName(streak.habitId);\n                    // Note: Notification service integration would be added here\n                    console.log(\n                        `Milestone achieved: ${milestone.days} days for ${habitName}`,\n                    );\n                } catch (error) {\n                    console.error(\"Error logging milestone achievement:\", error);\n                    // Don't throw - milestone was achieved successfully\n                }\n            }\n        }\n\n        return newMilestones;\n    }\n\n    /**\n     * Get streak information for a specific habit\n     */\n    async getHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak | null> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakDoc = await getDoc(streakDocRef);\n\n            if (!streakDoc.exists()) {\n                return null;\n            }\n\n            const streakData = streakDoc.data();\n            if (!validateStreakDocument(streakData)) {\n                throw new Error(\"Invalid streak data format\");\n            }\n\n            return transformFirestoreToStreak(streakData);\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Initialize streak data for a new habit\n     */\n    async initializeHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        const currentDate = getCurrentDateString(getUserTimezone());\n        const initialStreak: HabitStreak = {\n            habitId,\n            userId,\n            currentStreak: 0,\n            bestStreak: 0,\n            lastCompletionDate: \"\",\n            streakStartDate: currentDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(initialStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n\n            return initialStreak;\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to initialize habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Reset a streak (used when streak is broken and no freeze available)\n     * Requirements: 1.2, 11.3\n     */\n    async resetStreak(\n        habitId: string,\n        userId: string,\n        resetDate: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId || !resetDate) {\n            throw new Error(\"Habit ID, User ID, and reset date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    const resetStreak: HabitStreak = {\n                        ...streak,\n                        currentStreak: 0,\n                        lastCompletionDate: \"\",\n                        streakStartDate: resetDate,\n                    };\n\n                    const streakData = transformStreakToFirestore(resetStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    // Send recovery notification after streak is broken\n                    // Requirements: 11.3\n                    try {\n                        const habitName = await this.getHabitName(habitId);\n                        // Schedule recovery notification for tomorrow (handled by Cloud Functions)\n                        // The notification will be sent by the scheduled function\n                        console.log(\n                            `Streak broken for ${habitName}, recovery notification will be scheduled`,\n                        );\n                    } catch (error) {\n                        console.error(\"Error scheduling recovery notification:\", error);\n                        // Don't throw - streak reset was successful\n                    }\n\n                    return resetStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to reset streak: ${message}`);\n        }\n    }\n\n    // Private helper methods\n\n    /**\n     * Calculate streak from completion records\n     */\n    private calculateStreakFromCompletions(\n        completions: HabitCompletion[],\n        habitId: string,\n        userId: string,\n    ): HabitStreak {\n        if (completions.length === 0) {\n            return {\n                habitId,\n                userId,\n                currentStreak: 0,\n                bestStreak: 0,\n                lastCompletionDate: \"\",\n                streakStartDate: getCurrentDateString(getUserTimezone()),\n                freezesAvailable: 0,\n                freezesUsed: 0,\n                milestones: [],\n            };\n        }\n\n        const timezone = completions[0]?.timezone || getUserTimezone();\n        const completionDates = completions.map((comp) =>\n            timestampToDateString(comp.completedAt, timezone),\n        );\n\n        // Remove duplicates and sort\n        const uniqueDates = Array.from(new Set(completionDates)).sort();\n\n        // Calculate current streak (from most recent completion backwards)\n        let currentStreak = 0;\n        let streakStartDate = \"\";\n        const today = getCurrentDateString(timezone);\n        const yesterday = formatDateToString(\n            new Date(Date.now() - 24 * 60 * 60 * 1000),\n            timezone,\n        );\n\n        // Check if there's a completion today or yesterday to start counting\n        const lastCompletionDate = uniqueDates[uniqueDates.length - 1];\n        if (lastCompletionDate === today || lastCompletionDate === yesterday) {\n            currentStreak = 1;\n            streakStartDate = lastCompletionDate;\n\n            // Count backwards for consecutive days\n            for (let i = uniqueDates.length - 2; i >= 0; i--) {\n                const currentDate = uniqueDates[i + 1];\n                const previousDate = uniqueDates[i];\n\n                if (areConsecutiveDays(previousDate, currentDate)) {\n                    currentStreak++;\n                    streakStartDate = previousDate;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Calculate best streak (longest consecutive sequence)\n        let bestStreak = 0;\n        let tempStreak = 1;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            if (areConsecutiveDays(uniqueDates[i - 1], uniqueDates[i])) {\n                tempStreak++;\n            } else {\n                bestStreak = Math.max(bestStreak, tempStreak);\n                tempStreak = 1;\n            }\n        }\n        bestStreak = Math.max(bestStreak, tempStreak, currentStreak);\n\n        return {\n            habitId,\n            userId,\n            currentStreak,\n            bestStreak,\n            lastCompletionDate,\n            streakStartDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n    }\n\n    /**\n     * Merge calculated streak with existing streak data\n     */\n    private mergeStreakData(\n        calculated: HabitStreak,\n        existing: HabitStreak | null,\n    ): HabitStreak {\n        if (!existing) {\n            return calculated;\n        }\n\n        return {\n            ...calculated,\n            freezesAvailable: existing.freezesAvailable,\n            freezesUsed: existing.freezesUsed,\n            milestones: existing.milestones,\n            // Ensure best streak never decreases\n            bestStreak: Math.max(calculated.bestStreak, existing.bestStreak),\n        };\n    }\n\n    private async getHabitName(habitId: string): Promise<string> {\n        try {\n            // Assuming habits are stored in the goals collection\n            const goalRef = doc(\n                db,\n                `artifacts/oath-app/public/data/goals/${habitId}`,\n            );\n            const goalDoc = await getDoc(goalRef);\n\n            if (goalDoc.exists()) {\n                const goalData = goalDoc.data();\n                return goalData.description || \"Your habit\";\n            }\n\n            return \"Your habit\";\n        } catch (error) {\n            console.error(\"Error getting habit name:\", error);\n            return \"Your habit\";\n        }\n    }\n\n    /**\n     * Check if a date is within the current streak period\n     */\n    private isDateInCurrentStreak(\n        date: string,\n        streak: HabitStreak | null,\n    ): boolean {\n        if (!streak || streak.currentStreak === 0 || !streak.streakStartDate) {\n            return false;\n        }\n\n        const streakStart = parseDateString(streak.streakStartDate);\n        const checkDate = parseDateString(date);\n        const streakEnd = new Date(streakStart);\n        streakEnd.setDate(streakEnd.getDate() + streak.currentStreak - 1);\n\n        return checkDate >= streakStart && checkDate <= streakEnd;\n    }\n}\n\n// Export singleton instance\nexport const streakService = new StreakService();\n"],"mappings":"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","ignoreList":[]}