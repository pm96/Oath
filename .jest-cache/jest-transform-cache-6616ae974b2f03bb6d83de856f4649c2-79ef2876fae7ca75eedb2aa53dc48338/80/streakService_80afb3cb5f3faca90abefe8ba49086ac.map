{"version":3,"names":["_firestore","require","_firebaseConfig","_habitStreaks","_dateUtils","_errorHandling","_collections","_dataIntegrityService","_habitStreakSchemas","_syncService","StreakService","exports","_classCallCheck2","default","_createClass2","key","value","_calculateStreak","_asyncToGenerator2","habitId","userId","_this","Error","retryWithBackoff","runTransaction","db","_ref2","transaction","streakId","generateStreakId","streaksCollection","getHabitStreaksCollection","streakDocRef","doc","streakDoc","get","completionsCollection","getHabitCompletionsCollection","completionsQuery","query","where","completionsSnapshot","getDocs","completions","docs","map","transformFirestoreToCompletion","id","data","sort","a","b","completedAt","toMillis","calculatedStreak","calculateStreakFromCompletions","existingStreak","exists","transformFirestoreToStreak","updatedStreak","mergeStreakData","validationResult","streakValidationService","validateStreakCalculation","isValid","console","warn","errors","createAuditLog","finalStreak","correctedData","streakData","transformStreakToFirestore","set","integrityCheck","dataIntegrityService","verifyStreakIntegrity","warnings","_x3","apply","arguments","error","message","getUserFriendlyErrorMessage","calculateStreak","_x","_x2","_recordCompletion","completion","existingCompletionsQuery","existingSnapshot","existingCompletions","validateCompletionData","join","suspiciousActivity","userTimezone","timezone","getUserTimezone","completionDateString","timestampToDateString","currentDateString","getCurrentDateString","_ref4","sameDay","filter","comp","compDateString","length","completionData","notes","difficulty","createdAt","serverTimestamp","completionRef","newCompletion","Object","assign","syncService","queueOperation","type","action","_x5","recordCompletion","_x4","_recordCompletionWithMilestoneCheck","recordedCompletion","newMilestones","checkMilestones","recordCompletionWithMilestoneCheck","_x6","_useStreakFreeze","missedDate","_ref6","streak","validateUserOwnership","freezesAvailable","freezesUsed","protectedCompletion","Timestamp","fromDate","parseDateString","_x0","useStreakFreeze","_x7","_x8","_x9","_getHabitCalendar","days","_this2","endDate","startDate","formatDateToString","Date","now","getHabitStreak","dateRange","generateDateRange","calendarDays","date","find","isInStreak","isDateInCurrentStreak","completed","isToday","completionTime","toDate","toLocaleTimeString","undefined","getHabitCalendar","_x1","_x10","_x11","_x12","_checkMilestones","existingMilestoneDays","milestones","m","milestoneDay","MILESTONE_DAYS","currentStreak","includes","milestone","achievedAt","celebrated","push","concat","_toConsumableArray2","_ref8","_x14","habitName","getHabitName","log","_x13","_getHabitStreak","getDoc","validateStreakDocument","_x15","_x16","_getHabitStreakForFriend","friendId","validateDataForFriendDisplay","getHabitStreakForFriend","_x17","_x18","_x19","_initializeHabitStreak","currentDate","initialStreak","bestStreak","lastCompletionDate","streakStartDate","_ref9","_x22","initializeHabitStreak","_x20","_x21","_resetStreak","resetDate","_this3","_ref1","resetStreak","_x26","_x23","_x24","_x25","_completions$","completionDates","uniqueDates","Array","from","Set","today","yesterday","i","previousDate","areConsecutiveDays","tempStreak","Math","max","calculated","existing","_getHabitName","goalRef","goalDoc","goalData","description","_x27","streakStart","checkDate","streakEnd","setDate","getDate","streakService"],"sources":["streakService.ts"],"sourcesContent":["import {\n    doc,\n    getDoc,\n    getDocs,\n    query,\n    runTransaction,\n    serverTimestamp,\n    Timestamp,\n    where,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebaseConfig\";\nimport {\n    CalendarDay,\n    HabitCompletion,\n    HabitStreak,\n    MILESTONE_DAYS,\n    StreakMilestone,\n} from \"../../types/habit-streaks\";\nimport {\n    areConsecutiveDays,\n    formatDateToString,\n    generateDateRange,\n    getCurrentDateString,\n    getUserTimezone,\n    isToday,\n    parseDateString,\n    timestampToDateString,\n} from \"../../utils/dateUtils\";\nimport {\n    getUserFriendlyErrorMessage,\n    retryWithBackoff,\n} from \"../../utils/errorHandling\";\nimport {\n    getHabitCompletionsCollection,\n    getHabitStreaksCollection,\n} from \"./collections\";\nimport { dataIntegrityService } from \"./dataIntegrityService\";\nimport { StreakService as IStreakService } from \"./habitStreakInterfaces\";\nimport {\n    generateStreakId,\n    transformFirestoreToCompletion,\n    transformFirestoreToStreak,\n    transformStreakToFirestore,\n    validateStreakDocument,\n    validateUserOwnership,\n} from \"./habitStreakSchemas\";\nimport { syncService } from \"./syncService\";\n\n/**\n * StreakService Implementation\n *\n * Handles all streak calculation, tracking, and management functionality\n * with timezone awareness and data integrity protection.\n */\nexport class StreakService implements IStreakService {\n    /**\n     * Calculate and update streak information for a habit\n     * Requirements: 1.1, 1.2, 1.3, 10.2, 12.4\n     */\n    async calculateStreak(habitId: string, userId: string): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Get current streak data\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    // Get all completions for this habit\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", habitId),\n                        where(\"userId\", \"==\", userId),\n                    );\n                    const completionsSnapshot = await getDocs(completionsQuery);\n\n                    // Transform completions and sort by date\n                    const completions = completionsSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .sort(\n                            (a, b) => a.completedAt.toMillis() - b.completedAt.toMillis(),\n                        );\n\n                    // Calculate streak from completions\n                    const calculatedStreak = this.calculateStreakFromCompletions(\n                        completions,\n                        habitId,\n                        userId,\n                    );\n\n                    // Merge with existing data if available\n                    let existingStreak: HabitStreak | null = null;\n                    if (streakDoc.exists()) {\n                        existingStreak = transformFirestoreToStreak(streakDoc.data());\n                    }\n\n                    const updatedStreak = this.mergeStreakData(\n                        calculatedStreak,\n                        existingStreak,\n                    );\n\n                    // Server-side validation of streak calculation (Requirements 12.2)\n                    const validationResult =\n                        await streakValidationService.validateStreakCalculation(\n                            updatedStreak,\n                            completions,\n                            userId,\n                        );\n\n                    if (!validationResult.isValid) {\n                        console.warn(\n                            \"Streak calculation validation failed:\",\n                            validationResult.errors,\n                        );\n\n                        // Create audit log for validation failure\n                        await streakValidationService.createAuditLog(\n                            userId,\n                            \"streak_calculation_validation_failed\",\n                            \"streak\",\n                            streakId,\n                            existingStreak,\n                            updatedStreak,\n                            validationResult,\n                        );\n\n                        // Use corrected data if available\n                        const finalStreak = validationResult.correctedData || updatedStreak;\n\n                        // Save corrected streak\n                        const streakData = transformStreakToFirestore(finalStreak);\n                        transaction.set(streakDocRef, streakData);\n\n                        return finalStreak;\n                    }\n\n                    // Verify data integrity before saving (Requirements 12.4)\n                    const integrityCheck =\n                        await dataIntegrityService.verifyStreakIntegrity(\n                            habitId,\n                            userId,\n                            updatedStreak,\n                        );\n\n                    if (!integrityCheck.isValid) {\n                        console.warn(\n                            \"Streak integrity issues detected:\",\n                            integrityCheck.errors,\n                        );\n\n                        // Create audit log for integrity issues\n                        await streakValidationService.createAuditLog(\n                            userId,\n                            \"streak_integrity_check_failed\",\n                            \"streak\",\n                            streakId,\n                            existingStreak,\n                            updatedStreak,\n                            {\n                                isValid: false,\n                                errors: integrityCheck.errors,\n                                warnings: integrityCheck.warnings,\n                            },\n                        );\n\n                        // Use corrected data if available\n                        const finalStreak = integrityCheck.correctedData || updatedStreak;\n\n                        // Save corrected streak\n                        const streakData = transformStreakToFirestore(finalStreak);\n                        transaction.set(streakDocRef, streakData);\n\n                        return finalStreak;\n                    }\n\n                    // Save updated streak\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    // Create audit log for successful calculation\n                    await streakValidationService.createAuditLog(\n                        userId,\n                        \"streak_calculated\",\n                        \"streak\",\n                        streakId,\n                        existingStreak,\n                        updatedStreak,\n                        validationResult,\n                    );\n\n                    return updatedStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to calculate streak: ${message}`);\n        }\n    }\n\n    /**\n     * Record a new habit completion and update streak\n     * Requirements: 5.1, 12.1, 10.4\n     */\n    async recordCompletion(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<HabitCompletion> {\n        if (!completion.habitId || !completion.userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        // Get existing completions for validation\n        const completionsCollection = getHabitCompletionsCollection();\n        const existingCompletionsQuery = query(\n            completionsCollection,\n            where(\"habitId\", \"==\", completion.habitId),\n            where(\"userId\", \"==\", completion.userId),\n        );\n        const existingSnapshot = await getDocs(existingCompletionsQuery);\n        const existingCompletions = existingSnapshot.docs.map((doc) =>\n            transformFirestoreToCompletion(doc.id, doc.data()),\n        );\n\n        // Server-side validation of completion data (Requirements 12.1, 12.3)\n        const validationResult =\n            await streakValidationService.validateCompletionData(\n                completion,\n                completion.userId,\n                existingCompletions,\n            );\n\n        if (!validationResult.isValid) {\n            // Create audit log for validation failure\n            await streakValidationService.createAuditLog(\n                completion.userId,\n                \"completion_validation_failed\",\n                \"completion\",\n                \"pending\",\n                null,\n                completion,\n                validationResult,\n            );\n\n            throw new Error(\n                `Completion validation failed: ${validationResult.errors.join(\", \")}`,\n            );\n        }\n\n        // Log suspicious activity if detected\n        if (validationResult.suspiciousActivity) {\n            console.warn(\n                \"Suspicious completion activity detected:\",\n                validationResult.warnings,\n            );\n        }\n\n        // Validate timezone-aware completion\n        const userTimezone = completion.timezone || getUserTimezone();\n        const completionDateString = timestampToDateString(\n            completion.completedAt,\n            userTimezone,\n        );\n        const currentDateString = getCurrentDateString(userTimezone);\n\n        // Ensure completion is for current day or earlier (prevent future completions)\n        if (completionDateString > currentDateString) {\n            throw new Error(\"Cannot record completions for future dates\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Double-check for existing completion on the same date\n                    const sameDay = existingCompletions.filter((comp) => {\n                        const compDateString = timestampToDateString(\n                            comp.completedAt,\n                            userTimezone,\n                        );\n                        return compDateString === completionDateString;\n                    });\n\n                    if (sameDay.length > 0) {\n                        throw new Error(\"Habit already completed for this date\");\n                    }\n\n                    // Create completion record with metadata\n                    const completionData = {\n                        habitId: completion.habitId,\n                        userId: completion.userId,\n                        completedAt: completion.completedAt,\n                        timezone: userTimezone,\n                        notes: completion.notes || \"\",\n                        difficulty: completion.difficulty,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, completionData);\n\n                    const newCompletion: HabitCompletion = {\n                        id: completionRef.id,\n                        ...completion,\n                        timezone: userTimezone,\n                    };\n\n                    // Create audit log for successful completion\n                    await streakValidationService.createAuditLog(\n                        completion.userId,\n                        \"completion_recorded\",\n                        \"completion\",\n                        completionRef.id,\n                        null,\n                        completionData,\n                        validationResult,\n                    );\n\n                    // Queue for sync to other devices\n                    await syncService.queueOperation({\n                        type: \"completion\",\n                        action: \"create\",\n                        data: completionData,\n                        userId: completion.userId,\n                        habitId: completion.habitId,\n                    });\n\n                    return newCompletion;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to record completion: ${message}`);\n        }\n    }\n\n    /**\n     * Record completion and check for milestone achievements\n     * This is the main method that should be called when a user completes a habit\n     * Requirements: 3.1, 3.2, 5.1\n     */\n    async recordCompletionWithMilestoneCheck(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<{\n        completion: HabitCompletion;\n        newMilestones: StreakMilestone[];\n        updatedStreak: HabitStreak;\n    }> {\n        // Record the completion\n        const recordedCompletion = await this.recordCompletion(completion);\n\n        // Recalculate streak with the new completion\n        const updatedStreak = await this.calculateStreak(\n            completion.habitId,\n            completion.userId,\n        );\n\n        // Check for new milestones\n        const newMilestones = await this.checkMilestones(updatedStreak);\n\n        return {\n            completion: recordedCompletion,\n            newMilestones,\n            updatedStreak,\n        };\n    }\n\n    /**\n     * Use a streak freeze to protect from a missed day\n     * Requirements: 4.1, 4.2, 4.5\n     */\n    async useStreakFreeze(\n        habitId: string,\n        userId: string,\n        missedDate: string,\n    ): Promise<boolean> {\n        if (!habitId || !userId || !missedDate) {\n            throw new Error(\"Habit ID, User ID, and missed date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    // Check if freeze is available\n                    if (streak.freezesAvailable <= 0) {\n                        return false;\n                    }\n\n                    // Use the freeze\n                    const updatedStreak: HabitStreak = {\n                        ...streak,\n                        freezesAvailable: streak.freezesAvailable - 1,\n                        freezesUsed: streak.freezesUsed + 1,\n                    };\n\n                    // Create a \"protected\" completion record for the missed date\n                    const protectedCompletion = {\n                        habitId,\n                        userId,\n                        completedAt: Timestamp.fromDate(parseDateString(missedDate)),\n                        timezone: getUserTimezone(),\n                        notes: \"Protected by streak freeze\",\n                        difficulty: \"easy\" as const,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, protectedCompletion);\n\n                    // Update streak data\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return true;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to use streak freeze: ${message}`);\n        }\n    }\n\n    /**\n     * Get calendar data for a habit showing completion status\n     * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5\n     */\n    async getHabitCalendar(\n        habitId: string,\n        userId: string,\n        days: number,\n        timezone: string,\n    ): Promise<CalendarDay[]> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                // Get date range for calendar\n                const endDate = getCurrentDateString(timezone);\n                const startDate = formatDateToString(\n                    new Date(Date.now() - (days - 1) * 24 * 60 * 60 * 1000),\n                    timezone,\n                );\n\n                // Get completions for the date range\n                const completionsCollection = getHabitCompletionsCollection();\n                const completionsQuery = query(\n                    completionsCollection,\n                    where(\"habitId\", \"==\", habitId),\n                    where(\"userId\", \"==\", userId),\n                );\n                const completionsSnapshot = await getDocs(completionsQuery);\n\n                const completions = completionsSnapshot.docs\n                    .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                    .filter((completion) => {\n                        const compDateString = timestampToDateString(\n                            completion.completedAt,\n                            timezone,\n                        );\n                        return compDateString >= startDate && compDateString <= endDate;\n                    });\n\n                // Get streak data for highlighting\n                const streak = await this.getHabitStreak(habitId, userId);\n\n                // Generate calendar days\n                const dateRange = generateDateRange(startDate, endDate);\n                const calendarDays: CalendarDay[] = dateRange.map((date) => {\n                    const completion = completions.find(\n                        (comp) =>\n                            timestampToDateString(comp.completedAt, timezone) === date,\n                    );\n\n                    const isInStreak = this.isDateInCurrentStreak(date, streak);\n\n                    return {\n                        date,\n                        completed: !!completion,\n                        isToday: isToday(date, timezone),\n                        isInStreak,\n                        completionTime: completion\n                            ? completion.completedAt.toDate().toLocaleTimeString()\n                            : undefined,\n                        notes: completion?.notes,\n                    };\n                });\n\n                return calendarDays;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit calendar: ${message}`);\n        }\n    }\n\n    /**\n     * Check for new milestones and return any that should be celebrated\n     * Requirements: 3.1, 3.2, 4.4, 11.2\n     */\n    async checkMilestones(streak: HabitStreak): Promise<StreakMilestone[]> {\n        const newMilestones: StreakMilestone[] = [];\n        const existingMilestoneDays = streak.milestones.map((m) => m.days);\n\n        for (const milestoneDay of MILESTONE_DAYS) {\n            if (\n                streak.currentStreak >= milestoneDay &&\n                !existingMilestoneDays.includes(milestoneDay)\n            ) {\n                const milestone: StreakMilestone = {\n                    days: milestoneDay,\n                    achievedAt: Timestamp.now(),\n                    celebrated: false,\n                };\n                newMilestones.push(milestone);\n\n                // Award streak freeze for 30-day milestones (Requirement 4.4)\n                if (milestoneDay === 30) {\n                    streak.freezesAvailable += 1;\n                }\n            }\n        }\n\n        // Update streak with new milestones\n        if (newMilestones.length > 0) {\n            const updatedStreak: HabitStreak = {\n                ...streak,\n                milestones: [...streak.milestones, ...newMilestones],\n                // Update freezes if 30-day milestone was achieved\n                freezesAvailable: streak.freezesAvailable,\n            };\n\n            const streakId = generateStreakId(streak.userId, streak.habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(updatedStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n\n            // Send milestone notifications for new milestones\n            // Requirements: 11.2\n            for (const milestone of newMilestones) {\n                try {\n                    const habitName = await this.getHabitName(streak.habitId);\n                    // Note: Notification service integration would be added here\n                    console.log(\n                        `Milestone achieved: ${milestone.days} days for ${habitName}`,\n                    );\n                } catch (error) {\n                    console.error(\"Error logging milestone achievement:\", error);\n                    // Don't throw - milestone was achieved successfully\n                }\n            }\n        }\n\n        return newMilestones;\n    }\n\n    /**\n     * Get streak information for a specific habit\n     */\n    async getHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak | null> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakDoc = await getDoc(streakDocRef);\n\n            if (!streakDoc.exists()) {\n                return null;\n            }\n\n            const streakData = streakDoc.data();\n            if (!validateStreakDocument(streakData)) {\n                throw new Error(\"Invalid streak data format\");\n            }\n\n            return transformFirestoreToStreak(streakData);\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Get streak information for friend display with integrity verification\n     * Requirements: 12.4\n     */\n    async getHabitStreakForFriend(\n        habitId: string,\n        userId: string,\n        friendId: string,\n    ): Promise<HabitStreak | null> {\n        if (!habitId || !userId || !friendId) {\n            throw new Error(\"Habit ID, User ID, and Friend ID are required\");\n        }\n\n        try {\n            const streak = await this.getHabitStreak(habitId, userId);\n\n            if (!streak) {\n                return null;\n            }\n\n            // Validate data integrity before displaying to friend (Requirements 12.4)\n            const validationResult =\n                await streakValidationService.validateDataForFriendDisplay(\n                    streak,\n                    userId,\n                    friendId,\n                );\n\n            if (!validationResult.isValid) {\n                console.warn(\n                    \"Streak data failed friend display validation:\",\n                    validationResult.errors,\n                );\n\n                // Create audit log for failed friend access\n                await streakValidationService.createAuditLog(\n                    userId,\n                    \"friend_display_validation_failed\",\n                    \"streak\",\n                    generateStreakId(userId, habitId),\n                    null,\n                    streak,\n                    validationResult,\n                );\n\n                // Don't show invalid data to friends\n                return null;\n            }\n\n            // Create audit log for successful friend access\n            await streakValidationService.createAuditLog(\n                userId,\n                \"friend_accessed_streak\",\n                \"streak\",\n                generateStreakId(userId, habitId),\n                null,\n                { friendId, habitId },\n                validationResult,\n            );\n\n            return streak;\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit streak for friend: ${message}`);\n        }\n    }\n\n    /**\n     * Initialize streak data for a new habit\n     */\n    async initializeHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        const currentDate = getCurrentDateString(getUserTimezone());\n        const initialStreak: HabitStreak = {\n            habitId,\n            userId,\n            currentStreak: 0,\n            bestStreak: 0,\n            lastCompletionDate: \"\",\n            streakStartDate: currentDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(initialStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n\n            return initialStreak;\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to initialize habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Reset a streak (used when streak is broken and no freeze available)\n     * Requirements: 1.2, 11.3\n     */\n    async resetStreak(\n        habitId: string,\n        userId: string,\n        resetDate: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId || !resetDate) {\n            throw new Error(\"Habit ID, User ID, and reset date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    const resetStreak: HabitStreak = {\n                        ...streak,\n                        currentStreak: 0,\n                        lastCompletionDate: \"\",\n                        streakStartDate: resetDate,\n                    };\n\n                    const streakData = transformStreakToFirestore(resetStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    // Send recovery notification after streak is broken\n                    // Requirements: 11.3\n                    try {\n                        const habitName = await this.getHabitName(habitId);\n                        // Schedule recovery notification for tomorrow (handled by Cloud Functions)\n                        // The notification will be sent by the scheduled function\n                        console.log(\n                            `Streak broken for ${habitName}, recovery notification will be scheduled`,\n                        );\n                    } catch (error) {\n                        console.error(\"Error scheduling recovery notification:\", error);\n                        // Don't throw - streak reset was successful\n                    }\n\n                    return resetStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to reset streak: ${message}`);\n        }\n    }\n\n    // Private helper methods\n\n    /**\n     * Calculate streak from completion records\n     */\n    private calculateStreakFromCompletions(\n        completions: HabitCompletion[],\n        habitId: string,\n        userId: string,\n    ): HabitStreak {\n        if (completions.length === 0) {\n            return {\n                habitId,\n                userId,\n                currentStreak: 0,\n                bestStreak: 0,\n                lastCompletionDate: \"\",\n                streakStartDate: getCurrentDateString(getUserTimezone()),\n                freezesAvailable: 0,\n                freezesUsed: 0,\n                milestones: [],\n            };\n        }\n\n        const timezone = completions[0]?.timezone || getUserTimezone();\n        const completionDates = completions.map((comp) =>\n            timestampToDateString(comp.completedAt, timezone),\n        );\n\n        // Remove duplicates and sort\n        const uniqueDates = Array.from(new Set(completionDates)).sort();\n\n        // Calculate current streak (from most recent completion backwards)\n        let currentStreak = 0;\n        let streakStartDate = \"\";\n        const today = getCurrentDateString(timezone);\n        const yesterday = formatDateToString(\n            new Date(Date.now() - 24 * 60 * 60 * 1000),\n            timezone,\n        );\n\n        // Check if there's a completion today or yesterday to start counting\n        const lastCompletionDate = uniqueDates[uniqueDates.length - 1];\n        if (lastCompletionDate === today || lastCompletionDate === yesterday) {\n            currentStreak = 1;\n            streakStartDate = lastCompletionDate;\n\n            // Count backwards for consecutive days\n            for (let i = uniqueDates.length - 2; i >= 0; i--) {\n                const currentDate = uniqueDates[i + 1];\n                const previousDate = uniqueDates[i];\n\n                if (areConsecutiveDays(previousDate, currentDate)) {\n                    currentStreak++;\n                    streakStartDate = previousDate;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Calculate best streak (longest consecutive sequence)\n        let bestStreak = 0;\n        let tempStreak = 1;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            if (areConsecutiveDays(uniqueDates[i - 1], uniqueDates[i])) {\n                tempStreak++;\n            } else {\n                bestStreak = Math.max(bestStreak, tempStreak);\n                tempStreak = 1;\n            }\n        }\n        bestStreak = Math.max(bestStreak, tempStreak, currentStreak);\n\n        return {\n            habitId,\n            userId,\n            currentStreak,\n            bestStreak,\n            lastCompletionDate,\n            streakStartDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n    }\n\n    /**\n     * Merge calculated streak with existing streak data\n     */\n    private mergeStreakData(\n        calculated: HabitStreak,\n        existing: HabitStreak | null,\n    ): HabitStreak {\n        if (!existing) {\n            return calculated;\n        }\n\n        return {\n            ...calculated,\n            freezesAvailable: existing.freezesAvailable,\n            freezesUsed: existing.freezesUsed,\n            milestones: existing.milestones,\n            // Ensure best streak never decreases\n            bestStreak: Math.max(calculated.bestStreak, existing.bestStreak),\n        };\n    }\n\n    private async getHabitName(habitId: string): Promise<string> {\n        try {\n            // Assuming habits are stored in the goals collection\n            const goalRef = doc(\n                db,\n                `artifacts/oath-app/public/data/goals/${habitId}`,\n            );\n            const goalDoc = await getDoc(goalRef);\n\n            if (goalDoc.exists()) {\n                const goalData = goalDoc.data();\n                return goalData.description || \"Your habit\";\n            }\n\n            return \"Your habit\";\n        } catch (error) {\n            console.error(\"Error getting habit name:\", error);\n            return \"Your habit\";\n        }\n    }\n\n    /**\n     * Check if a date is within the current streak period\n     */\n    private isDateInCurrentStreak(\n        date: string,\n        streak: HabitStreak | null,\n    ): boolean {\n        if (!streak || streak.currentStreak === 0 || !streak.streakStartDate) {\n            return false;\n        }\n\n        const streakStart = parseDateString(streak.streakStartDate);\n        const checkDate = parseDateString(date);\n        const streakEnd = new Date(streakStart);\n        streakEnd.setDate(streakEnd.getDate() + streak.currentStreak - 1);\n\n        return checkDate >= streakStart && checkDate <= streakEnd;\n    }\n}\n\n// Export singleton instance\nexport const streakService = new StreakService();\n"],"mappings":"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","ignoreList":[]}