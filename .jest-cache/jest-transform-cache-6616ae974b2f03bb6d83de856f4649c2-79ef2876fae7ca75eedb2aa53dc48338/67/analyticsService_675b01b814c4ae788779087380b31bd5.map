{"version":3,"names":["_firestore","require","_firebaseConfig","_dateUtils","_errorHandling","_collections","_habitStreakSchemas","AnalyticsService","exports","_classCallCheck2","default","_createClass2","key","value","_calculateHabitAnalytics","_asyncToGenerator2","habitId","userId","_this","Error","retryWithBackoff","completions","getAllCompletions","length","createEmptyAnalytics","timezone","getUserTimezone","thirtyDaysAgo","getDateNDaysAgo","recentCompletions","filterCompletionsByDateRange","getCurrentDateString","totalCompletions","completionRate30Days","calculateCompletionRate","averageStreakLength","calculateAverageStreakLength","bestDayOfWeek","calculateBestDayOfWeek","consistencyScore","calculateConsistencyScore","analytics","lastUpdated","Timestamp","now","storeAnalytics","error","message","getUserFriendlyErrorMessage","calculateHabitAnalytics","_x","_x2","apply","arguments","_getCompletionTrends","period","_this2","periodDays","getPeriodDays","trends","i","getSegmentSize","endDate","startDate","segmentCompletions","completionRate","streakLength","calculateSegmentStreakLength","unshift","formatPeriodLabel","getCompletionTrends","_x3","_x4","_x5","_getOverallConsistencyScore","_this3","completionsCollection","getHabitCompletionsCollection","allCompletionsQuery","query","where","allCompletionsSnapshot","getDocs","habitIds","Set","docs","forEach","doc","completion","transformFirestoreToCompletion","id","data","add","size","habitScores","push","_unused","totalScore","reduce","sum","score","Math","round","getOverallConsistencyScore","_x6","_getBestDayOfWeek","getBestDayOfWeek","_x7","_x8","_getCompletionRate","filteredCompletions","totalDays","calculateDaysBetween","getCompletionRate","_x9","_x0","_x1","_x10","_getMultiHabitAnalytics","_this4","analyticsPromises","map","results","Promise","allSettled","filter","result","status","getMultiHabitAnalytics","_x11","_x12","_getAllCompletions","completionsQuery","completionsSnapshot","sort","a","b","completedAt","toMillis","_x13","_x14","completionDate","timestampToDateString","uniqueDates","dayStats","dayNames","dayName","index","totalPossible","rate","dayOfWeek","getDayOfWeek","firstCompletion","lastCompletion","weeksSpanned","ceil","_","bestDay","Object","values","dayStat","_calculateAverageStreakLength","streaksCollection","getHabitStreaksCollection","streakQuery","streakSnapshot","empty","streakDoc","streak","transformFirestoreToStreak","bestStreak","calculateStreakLengthFromCompletions","_unused2","_x15","_x16","_x17","completionDates","Array","from","streaks","currentStreak","prevDate","Date","currDate","diffDays","getTime","totalStreakDays","completionScore","min","streakScore","calculateStreakConsistency","dayConsistencyScore","calculateDayConsistency","overallScore","consecutiveDays","totalGaps","totalPossibleDays","consistencyRatio","dayFrequency","frequencies","mean","freq","variance","pow","stdDev","sqrt","coefficientOfVariation","max","_storeAnalytics","analyticsId","analyticsCollection","getHabitAnalyticsCollection","analyticsDocRef","runTransaction","db","_ref4","transaction","analyticsData","serverTimestamp","set","_x19","_x18","start","end","toLocaleDateString","month","day","maxStreak","diffTime","analyticsService"],"sources":["analyticsService.ts"],"sourcesContent":["import {\n    doc,\n    getDocs,\n    query,\n    runTransaction,\n    serverTimestamp,\n    Timestamp,\n    where,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebaseConfig\";\nimport {\n    HabitAnalytics,\n    HabitCompletion,\n    TrendData,\n} from \"../../types/habit-streaks\";\nimport {\n    getCurrentDateString,\n    getDateNDaysAgo,\n    getDayOfWeek,\n    getUserTimezone,\n    timestampToDateString\n} from \"../../utils/dateUtils\";\nimport {\n    getUserFriendlyErrorMessage,\n    retryWithBackoff,\n} from \"../../utils/errorHandling\";\nimport {\n    getHabitAnalyticsCollection,\n    getHabitCompletionsCollection,\n    getHabitStreaksCollection,\n} from \"./collections\";\nimport { AnalyticsService as IAnalyticsService } from \"./habitStreakInterfaces\";\nimport {\n    transformFirestoreToCompletion,\n    transformFirestoreToStreak\n} from \"./habitStreakSchemas\";\n\n/**\n * Analytics calculation interfaces\n */\ninterface DayOfWeekStats {\n    [key: string]: {\n        dayName: string;\n        completions: number;\n        totalPossible: number;\n        rate: number;\n    };\n}\n\ninterface StreakAnalysis {\n    totalStreaks: number;\n    averageLength: number;\n    longestStreak: number;\n    currentStreak: number;\n}\n\ninterface ConsistencyMetrics {\n    completionRate: number;\n    streakConsistency: number;\n    dayOfWeekConsistency: number;\n    overallScore: number;\n}\n\n/**\n * AnalyticsService Implementation\n *\n * Handles comprehensive analytics calculation for habit tracking including\n * trend analysis, consistency scoring, and performance improvement detection.\n * Requirements: 6.1, 6.2, 6.3, 6.4, 6.5\n */\nexport class AnalyticsService implements IAnalyticsService {\n    /**\n     * Calculate comprehensive analytics for a habit\n     * Requirements: 6.1, 6.2, 6.3, 6.4\n     */\n    async calculateHabitAnalytics(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitAnalytics> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                // Get all completions for this habit\n                const completions = await this.getAllCompletions(habitId, userId);\n\n                if (completions.length === 0) {\n                    return this.createEmptyAnalytics(habitId, userId);\n                }\n\n                // Calculate various metrics\n                const timezone = getUserTimezone();\n                const thirtyDaysAgo = getDateNDaysAgo(30, timezone);\n                const recentCompletions = this.filterCompletionsByDateRange(\n                    completions,\n                    thirtyDaysAgo,\n                    getCurrentDateString(timezone),\n                    timezone,\n                );\n\n                const totalCompletions = completions.length;\n                const completionRate30Days = this.calculateCompletionRate(\n                    recentCompletions,\n                    30,\n                    timezone,\n                );\n                const averageStreakLength = await this.calculateAverageStreakLength(\n                    habitId,\n                    userId,\n                    completions,\n                );\n                const bestDayOfWeek = this.calculateBestDayOfWeek(\n                    completions,\n                    timezone,\n                );\n                const consistencyScore = this.calculateConsistencyScore(\n                    completions,\n                    timezone,\n                );\n\n                const analytics: HabitAnalytics = {\n                    habitId,\n                    userId,\n                    totalCompletions,\n                    completionRate30Days,\n                    averageStreakLength,\n                    bestDayOfWeek,\n                    consistencyScore,\n                    lastUpdated: Timestamp.now(),\n                };\n\n                // Store analytics in database\n                await this.storeAnalytics(analytics);\n\n                return analytics;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to calculate habit analytics: ${message}`);\n        }\n    }\n\n    /**\n     * Get completion trends over a specified period\n     * Requirements: 6.1, 6.5\n     */\n    async getCompletionTrends(\n        habitId: string,\n        userId: string,\n        period: \"week\" | \"month\" | \"quarter\" | \"year\",\n    ): Promise<TrendData[]> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                const completions = await this.getAllCompletions(habitId, userId);\n                const timezone = getUserTimezone();\n\n                const periodDays = this.getPeriodDays(period);\n                const trends: TrendData[] = [];\n\n                // Calculate trends for each period segment\n                for (let i = 0; i < periodDays; i += this.getSegmentSize(period)) {\n                    const endDate = getDateNDaysAgo(i, timezone);\n                    const startDate = getDateNDaysAgo(\n                        i + this.getSegmentSize(period) - 1,\n                        timezone,\n                    );\n\n                    const segmentCompletions = this.filterCompletionsByDateRange(\n                        completions,\n                        startDate,\n                        endDate,\n                        timezone,\n                    );\n\n                    const completionRate = this.calculateCompletionRate(\n                        segmentCompletions,\n                        this.getSegmentSize(period),\n                        timezone,\n                    );\n\n                    const streakLength = this.calculateSegmentStreakLength(\n                        segmentCompletions,\n                        timezone,\n                    );\n\n                    trends.unshift({\n                        period: this.formatPeriodLabel(startDate, endDate, period),\n                        completionRate,\n                        streakLength,\n                        totalCompletions: segmentCompletions.length,\n                    });\n                }\n\n                return trends;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get completion trends: ${message}`);\n        }\n    }\n\n    /**\n     * Calculate overall consistency score across all user habits\n     * Requirements: 6.4\n     */\n    async getOverallConsistencyScore(userId: string): Promise<number> {\n        if (!userId) {\n            throw new Error(\"User ID is required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                // Get all habits for the user by finding unique habit IDs in completions\n                const completionsCollection = getHabitCompletionsCollection();\n                const allCompletionsQuery = query(\n                    completionsCollection,\n                    where(\"userId\", \"==\", userId),\n                );\n                const allCompletionsSnapshot = await getDocs(allCompletionsQuery);\n\n                const habitIds = new Set<string>();\n                allCompletionsSnapshot.docs.forEach((doc) => {\n                    const completion = transformFirestoreToCompletion(doc.id, doc.data());\n                    habitIds.add(completion.habitId);\n                });\n\n                if (habitIds.size === 0) {\n                    return 0;\n                }\n\n                // Calculate consistency score for each habit\n                const habitScores: number[] = [];\n                for (const habitId of habitIds) {\n                    try {\n                        const analytics = await this.calculateHabitAnalytics(\n                            habitId,\n                            userId,\n                        );\n                        habitScores.push(analytics.consistencyScore);\n                    } catch {\n                        // Skip habits that can't be analyzed\n                        continue;\n                    }\n                }\n\n                if (habitScores.length === 0) {\n                    return 0;\n                }\n\n                // Calculate weighted average (more recent habits have higher weight)\n                const totalScore = habitScores.reduce((sum, score) => sum + score, 0);\n                return Math.round((totalScore / habitScores.length) * 100) / 100;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get overall consistency score: ${message}`);\n        }\n    }\n\n    /**\n     * Get the most consistent day of the week for a habit\n     * Requirements: 6.2\n     */\n    async getBestDayOfWeek(habitId: string, userId: string): Promise<string> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            const completions = await this.getAllCompletions(habitId, userId);\n            const timezone = getUserTimezone();\n            return this.calculateBestDayOfWeek(completions, timezone);\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get best day of week: ${message}`);\n        }\n    }\n\n    /**\n     * Calculate completion rate for a specific time period\n     * Requirements: 6.1, 6.3\n     */\n    async getCompletionRate(\n        habitId: string,\n        userId: string,\n        startDate: string,\n        endDate: string,\n    ): Promise<number> {\n        if (!habitId || !userId || !startDate || !endDate) {\n            throw new Error(\n                \"All parameters are required for completion rate calculation\",\n            );\n        }\n\n        try {\n            const completions = await this.getAllCompletions(habitId, userId);\n            const timezone = getUserTimezone();\n\n            const filteredCompletions = this.filterCompletionsByDateRange(\n                completions,\n                startDate,\n                endDate,\n                timezone,\n            );\n\n            const totalDays = this.calculateDaysBetween(startDate, endDate);\n            return this.calculateCompletionRate(\n                filteredCompletions,\n                totalDays,\n                timezone,\n            );\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to calculate completion rate: ${message}`);\n        }\n    }\n\n    /**\n     * Get analytics for multiple habits (dashboard view)\n     * Requirements: 6.4\n     */\n    async getMultiHabitAnalytics(\n        habitIds: string[],\n        userId: string,\n    ): Promise<HabitAnalytics[]> {\n        if (!habitIds.length || !userId) {\n            throw new Error(\"Habit IDs and User ID are required\");\n        }\n\n        try {\n            const analyticsPromises = habitIds.map((habitId) =>\n                this.calculateHabitAnalytics(habitId, userId),\n            );\n\n            const results = await Promise.allSettled(analyticsPromises);\n\n            return results\n                .filter(\n                    (result): result is PromiseFulfilledResult<HabitAnalytics> =>\n                        result.status === \"fulfilled\",\n                )\n                .map((result) => result.value);\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get multi-habit analytics: ${message}`);\n        }\n    }\n\n    // Private helper methods\n\n    /**\n     * Get all completions for a habit\n     */\n    private async getAllCompletions(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitCompletion[]> {\n        const completionsCollection = getHabitCompletionsCollection();\n        const completionsQuery = query(\n            completionsCollection,\n            where(\"habitId\", \"==\", habitId),\n            where(\"userId\", \"==\", userId),\n        );\n\n        const completionsSnapshot = await getDocs(completionsQuery);\n        return completionsSnapshot.docs\n            .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n            .sort((a, b) => a.completedAt.toMillis() - b.completedAt.toMillis());\n    }\n\n    /**\n     * Filter completions by date range\n     */\n    private filterCompletionsByDateRange(\n        completions: HabitCompletion[],\n        startDate: string,\n        endDate: string,\n        timezone: string,\n    ): HabitCompletion[] {\n        return completions.filter((completion) => {\n            const completionDate = timestampToDateString(\n                completion.completedAt,\n                timezone,\n            );\n            return completionDate >= startDate && completionDate <= endDate;\n        });\n    }\n\n    /**\n     * Calculate completion rate as percentage\n     */\n    private calculateCompletionRate(\n        completions: HabitCompletion[],\n        totalDays: number,\n        timezone: string,\n    ): number {\n        if (totalDays <= 0) return 0;\n\n        const uniqueDates = new Set(\n            completions.map((completion) =>\n                timestampToDateString(completion.completedAt, timezone),\n            ),\n        );\n\n        return Math.round((uniqueDates.size / totalDays) * 10000) / 100; // Round to 2 decimal places\n    }\n\n    /**\n     * Calculate the best day of the week based on completion frequency\n     */\n    private calculateBestDayOfWeek(\n        completions: HabitCompletion[],\n        timezone: string,\n    ): string {\n        if (completions.length === 0) return \"Monday\";\n\n        const dayStats: DayOfWeekStats = {};\n        const dayNames = [\n            \"Sunday\",\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n        ];\n\n        // Initialize day stats\n        dayNames.forEach((dayName, index) => {\n            dayStats[index] = {\n                dayName,\n                completions: 0,\n                totalPossible: 0,\n                rate: 0,\n            };\n        });\n\n        // Count completions by day of week\n        completions.forEach((completion) => {\n            const completionDate = timestampToDateString(\n                completion.completedAt,\n                timezone,\n            );\n            const dayOfWeek = getDayOfWeek(completionDate);\n            dayStats[dayOfWeek].completions++;\n        });\n\n        // Calculate total possible days for each day of the week\n        if (completions.length > 0) {\n            const firstCompletion = completions[0];\n            const lastCompletion = completions[completions.length - 1];\n            const startDate = timestampToDateString(\n                firstCompletion.completedAt,\n                timezone,\n            );\n            const endDate = timestampToDateString(\n                lastCompletion.completedAt,\n                timezone,\n            );\n\n            const totalDays = this.calculateDaysBetween(startDate, endDate);\n            const weeksSpanned = Math.ceil(totalDays / 7);\n\n            dayNames.forEach((_, index) => {\n                dayStats[index].totalPossible = weeksSpanned;\n                dayStats[index].rate =\n                    dayStats[index].totalPossible > 0\n                        ? dayStats[index].completions / dayStats[index].totalPossible\n                        : 0;\n            });\n        }\n\n        // Find the day with the highest completion rate\n        let bestDay = dayStats[0];\n        Object.values(dayStats).forEach((dayStat) => {\n            if (dayStat.rate > bestDay.rate) {\n                bestDay = dayStat;\n            }\n        });\n\n        return bestDay.dayName;\n    }\n\n    /**\n     * Calculate average streak length from completions\n     */\n    private async calculateAverageStreakLength(\n        habitId: string,\n        userId: string,\n        completions: HabitCompletion[],\n    ): Promise<number> {\n        if (completions.length === 0) return 0;\n\n        try {\n            // Get current streak data\n            const streaksCollection = getHabitStreaksCollection();\n            const streakQuery = query(\n                streaksCollection,\n                where(\"habitId\", \"==\", habitId),\n                where(\"userId\", \"==\", userId),\n            );\n            const streakSnapshot = await getDocs(streakQuery);\n\n            if (!streakSnapshot.empty) {\n                const streakDoc = streakSnapshot.docs[0];\n                const streak = transformFirestoreToStreak(streakDoc.data());\n\n                // Use best streak as a proxy for average (could be enhanced with historical data)\n                return streak.bestStreak;\n            }\n\n            // Fallback: calculate from completion patterns\n            return this.calculateStreakLengthFromCompletions(completions);\n        } catch {\n            // Fallback calculation if streak data is unavailable\n            return this.calculateStreakLengthFromCompletions(completions);\n        }\n    }\n\n    /**\n     * Calculate streak length from completion patterns\n     */\n    private calculateStreakLengthFromCompletions(\n        completions: HabitCompletion[],\n    ): number {\n        if (completions.length === 0) return 0;\n\n        const timezone = getUserTimezone();\n        const completionDates = completions\n            .map((completion) =>\n                timestampToDateString(completion.completedAt, timezone),\n            )\n            .sort();\n\n        const uniqueDates = Array.from(new Set(completionDates));\n\n        let streaks: number[] = [];\n        let currentStreak = 1;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            const prevDate = new Date(uniqueDates[i - 1]);\n            const currDate = new Date(uniqueDates[i]);\n            const diffDays = Math.round(\n                (currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24),\n            );\n\n            if (diffDays === 1) {\n                currentStreak++;\n            } else {\n                streaks.push(currentStreak);\n                currentStreak = 1;\n            }\n        }\n        streaks.push(currentStreak);\n\n        const totalStreakDays = streaks.reduce((sum, streak) => sum + streak, 0);\n        return Math.round((totalStreakDays / streaks.length) * 100) / 100;\n    }\n\n    /**\n     * Calculate consistency score based on multiple factors\n     */\n    private calculateConsistencyScore(\n        completions: HabitCompletion[],\n        timezone: string,\n    ): number {\n        if (completions.length === 0) return 0;\n\n        const thirtyDaysAgo = getDateNDaysAgo(30, timezone);\n        const recentCompletions = this.filterCompletionsByDateRange(\n            completions,\n            thirtyDaysAgo,\n            getCurrentDateString(timezone),\n            timezone,\n        );\n\n        // Factor 1: Completion rate (40% weight)\n        const completionRate = this.calculateCompletionRate(\n            recentCompletions,\n            30,\n            timezone,\n        );\n        const completionScore = Math.min(completionRate, 100);\n\n        // Factor 2: Streak consistency (30% weight)\n        const streakScore = this.calculateStreakConsistency(\n            recentCompletions,\n            timezone,\n        );\n\n        // Factor 3: Day-of-week consistency (30% weight)\n        const dayConsistencyScore = this.calculateDayConsistency(\n            recentCompletions,\n            timezone,\n        );\n\n        // Weighted average\n        const overallScore =\n            completionScore * 0.4 + streakScore * 0.3 + dayConsistencyScore * 0.3;\n\n        return Math.round(overallScore * 100) / 100;\n    }\n\n    /**\n     * Calculate streak consistency score\n     */\n    private calculateStreakConsistency(\n        completions: HabitCompletion[],\n        timezone: string,\n    ): number {\n        if (completions.length === 0) return 0;\n\n        const completionDates = completions\n            .map((completion) =>\n                timestampToDateString(completion.completedAt, timezone),\n            )\n            .sort();\n\n        const uniqueDates = Array.from(new Set(completionDates));\n\n        if (uniqueDates.length < 2) return 100;\n\n        let consecutiveDays = 0;\n        let totalGaps = 0;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            const prevDate = new Date(uniqueDates[i - 1]);\n            const currDate = new Date(uniqueDates[i]);\n            const diffDays = Math.round(\n                (currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24),\n            );\n\n            if (diffDays === 1) {\n                consecutiveDays++;\n            } else {\n                totalGaps += diffDays - 1;\n            }\n        }\n\n        const totalPossibleDays = uniqueDates.length - 1;\n        const consistencyRatio =\n            totalPossibleDays > 0 ? consecutiveDays / totalPossibleDays : 0;\n\n        return Math.min(consistencyRatio * 100, 100);\n    }\n\n    /**\n     * Calculate day-of-week consistency score\n     */\n    private calculateDayConsistency(\n        completions: HabitCompletion[],\n        timezone: string,\n    ): number {\n        if (completions.length === 0) return 0;\n\n        const dayFrequency: { [key: number]: number } = {};\n\n        completions.forEach((completion) => {\n            const completionDate = timestampToDateString(\n                completion.completedAt,\n                timezone,\n            );\n            const dayOfWeek = getDayOfWeek(completionDate);\n            dayFrequency[dayOfWeek] = (dayFrequency[dayOfWeek] || 0) + 1;\n        });\n\n        const frequencies = Object.values(dayFrequency);\n        if (frequencies.length === 0) return 0;\n\n        // Calculate coefficient of variation (lower is more consistent)\n        const mean =\n            frequencies.reduce((sum, freq) => sum + freq, 0) / frequencies.length;\n        const variance =\n            frequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) /\n            frequencies.length;\n        const stdDev = Math.sqrt(variance);\n\n        const coefficientOfVariation = mean > 0 ? stdDev / mean : 1;\n\n        // Convert to consistency score (0-100, higher is better)\n        return Math.max(0, Math.min(100, (1 - coefficientOfVariation) * 100));\n    }\n\n    /**\n     * Create empty analytics for habits with no completions\n     */\n    private createEmptyAnalytics(\n        habitId: string,\n        userId: string,\n    ): HabitAnalytics {\n        return {\n            habitId,\n            userId,\n            totalCompletions: 0,\n            completionRate30Days: 0,\n            averageStreakLength: 0,\n            bestDayOfWeek: \"Monday\",\n            consistencyScore: 0,\n            lastUpdated: Timestamp.now(),\n        };\n    }\n\n    /**\n     * Store analytics in the database\n     */\n    private async storeAnalytics(analytics: HabitAnalytics): Promise<void> {\n        const analyticsId = `${analytics.userId}_${analytics.habitId}`;\n        const analyticsCollection = getHabitAnalyticsCollection();\n        const analyticsDocRef = doc(analyticsCollection, analyticsId);\n\n        await runTransaction(db, async (transaction) => {\n            const analyticsData = {\n                habitId: analytics.habitId,\n                userId: analytics.userId,\n                totalCompletions: analytics.totalCompletions,\n                completionRate30Days: analytics.completionRate30Days,\n                averageStreakLength: analytics.averageStreakLength,\n                bestDayOfWeek: analytics.bestDayOfWeek,\n                consistencyScore: analytics.consistencyScore,\n                lastUpdated: serverTimestamp(),\n            };\n\n            transaction.set(analyticsDocRef, analyticsData);\n        });\n    }\n\n    /**\n     * Get number of days for a period\n     */\n    private getPeriodDays(period: \"week\" | \"month\" | \"quarter\" | \"year\"): number {\n        switch (period) {\n            case \"week\":\n                return 7;\n            case \"month\":\n                return 30;\n            case \"quarter\":\n                return 90;\n            case \"year\":\n                return 365;\n            default:\n                return 30;\n        }\n    }\n\n    /**\n     * Get segment size for trend analysis\n     */\n    private getSegmentSize(\n        period: \"week\" | \"month\" | \"quarter\" | \"year\",\n    ): number {\n        switch (period) {\n            case \"week\":\n                return 1; // Daily segments\n            case \"month\":\n                return 7; // Weekly segments\n            case \"quarter\":\n                return 30; // Monthly segments\n            case \"year\":\n                return 30; // Monthly segments\n            default:\n                return 7;\n        }\n    }\n\n    /**\n     * Format period label for trends\n     */\n    private formatPeriodLabel(\n        startDate: string,\n        endDate: string,\n        period: \"week\" | \"month\" | \"quarter\" | \"year\",\n    ): string {\n        if (period === \"week\") {\n            return endDate; // Daily labels\n        }\n\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n\n        if (period === \"month\") {\n            return `Week of ${end.toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" })}`;\n        }\n\n        return `${start.toLocaleDateString(\"en-US\", { month: \"short\" })} - ${end.toLocaleDateString(\"en-US\", { month: \"short\" })}`;\n    }\n\n    /**\n     * Calculate streak length for a segment\n     */\n    private calculateSegmentStreakLength(\n        completions: HabitCompletion[],\n        timezone: string,\n    ): number {\n        if (completions.length === 0) return 0;\n\n        const completionDates = completions\n            .map((completion) =>\n                timestampToDateString(completion.completedAt, timezone),\n            )\n            .sort();\n\n        const uniqueDates = Array.from(new Set(completionDates));\n\n        if (uniqueDates.length < 2) return uniqueDates.length;\n\n        let maxStreak = 1;\n        let currentStreak = 1;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            const prevDate = new Date(uniqueDates[i - 1]);\n            const currDate = new Date(uniqueDates[i]);\n            const diffDays = Math.round(\n                (currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24),\n            );\n\n            if (diffDays === 1) {\n                currentStreak++;\n                maxStreak = Math.max(maxStreak, currentStreak);\n            } else {\n                currentStreak = 1;\n            }\n        }\n\n        return maxStreak;\n    }\n\n    /**\n     * Calculate days between two date strings\n     */\n    private calculateDaysBetween(startDate: string, endDate: string): number {\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n        const diffTime = end.getTime() - start.getTime();\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 to include both start and end dates\n    }\n}\n\n// Export singleton instance\nexport const analyticsService = new AnalyticsService();\n"],"mappings":"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","ignoreList":[]}