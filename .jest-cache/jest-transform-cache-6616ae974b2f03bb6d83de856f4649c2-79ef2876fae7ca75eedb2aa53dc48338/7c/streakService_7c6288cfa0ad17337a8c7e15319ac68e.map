{"version":3,"names":["_firestore","require","_firebaseConfig","_habitStreaks","_dateUtils","_errorHandling","_collections","_habitStreakSchemas","StreakService","exports","_classCallCheck2","default","_createClass2","key","value","_calculateStreak","_asyncToGenerator2","habitId","userId","_this","Error","retryWithBackoff","runTransaction","db","_ref2","transaction","streakId","generateStreakId","streaksCollection","getHabitStreaksCollection","streakDocRef","doc","streakDoc","get","completionsCollection","getHabitCompletionsCollection","completionsQuery","query","where","completionsSnapshot","getDocs","completions","docs","map","transformFirestoreToCompletion","id","data","sort","a","b","completedAt","toMillis","calculatedStreak","calculateStreakFromCompletions","existingStreak","exists","transformFirestoreToStreak","updatedStreak","mergeStreakData","streakData","transformStreakToFirestore","set","_x3","apply","arguments","error","message","getUserFriendlyErrorMessage","calculateStreak","_x","_x2","_recordCompletion","completion","userTimezone","timezone","getUserTimezone","completionDateString","timestampToDateString","currentDateString","getCurrentDateString","_ref4","existingCompletionsQuery","existingSnapshot","existingCompletions","filter","comp","compDateString","length","completionData","notes","difficulty","createdAt","serverTimestamp","completionRef","newCompletion","Object","assign","_x5","recordCompletion","_x4","_recordCompletionWithMilestoneCheck","recordedCompletion","newMilestones","checkMilestones","recordCompletionWithMilestoneCheck","_x6","_useStreakFreeze","missedDate","_ref6","streak","validateUserOwnership","freezesAvailable","freezesUsed","protectedCompletion","Timestamp","fromDate","parseDateString","_x0","useStreakFreeze","_x7","_x8","_x9","_getHabitCalendar","days","_this2","endDate","startDate","formatDateToString","Date","now","getHabitStreak","dateRange","generateDateRange","calendarDays","date","find","isInStreak","isDateInCurrentStreak","completed","isToday","completionTime","toDate","toLocaleTimeString","undefined","getHabitCalendar","_x1","_x10","_x11","_x12","_checkMilestones","existingMilestoneDays","milestones","m","milestoneDay","MILESTONE_DAYS","currentStreak","includes","milestone","achievedAt","celebrated","push","concat","_toConsumableArray2","_ref8","_x14","_x13","_getHabitStreak","getDoc","validateStreakDocument","_x15","_x16","_initializeHabitStreak","currentDate","initialStreak","bestStreak","lastCompletionDate","streakStartDate","_ref9","_x19","initializeHabitStreak","_x17","_x18","_resetStreak","resetDate","_ref1","resetStreak","_x23","_x20","_x21","_x22","_completions$","completionDates","uniqueDates","Array","from","Set","today","yesterday","i","previousDate","areConsecutiveDays","tempStreak","Math","max","calculated","existing","streakStart","checkDate","streakEnd","setDate","getDate","streakService"],"sources":["streakService.ts"],"sourcesContent":["import {\n    doc,\n    getDoc,\n    getDocs,\n    query,\n    runTransaction,\n    serverTimestamp,\n    Timestamp,\n    where,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebaseConfig\";\nimport {\n    CalendarDay,\n    HabitCompletion,\n    HabitStreak,\n    MILESTONE_DAYS,\n    StreakMilestone,\n} from \"../../types/habit-streaks\";\nimport {\n    areConsecutiveDays,\n    formatDateToString,\n    generateDateRange,\n    getCurrentDateString,\n    getUserTimezone,\n    isToday,\n    parseDateString,\n    timestampToDateString,\n} from \"../../utils/dateUtils\";\nimport {\n    getUserFriendlyErrorMessage,\n    retryWithBackoff,\n} from \"../../utils/errorHandling\";\nimport {\n    getHabitCompletionsCollection,\n    getHabitStreaksCollection,\n} from \"./collections\";\nimport { StreakService as IStreakService } from \"./habitStreakInterfaces\";\nimport {\n    generateStreakId,\n    transformFirestoreToCompletion,\n    transformFirestoreToStreak,\n    transformStreakToFirestore,\n    validateStreakDocument,\n    validateUserOwnership,\n} from \"./habitStreakSchemas\";\n\n/**\n * StreakService Implementation\n *\n * Handles all streak calculation, tracking, and management functionality\n * with timezone awareness and data integrity protection.\n */\nexport class StreakService implements IStreakService {\n    /**\n     * Calculate and update streak information for a habit\n     * Requirements: 1.1, 1.2, 1.3\n     */\n    async calculateStreak(habitId: string, userId: string): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Get current streak data\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    // Get all completions for this habit\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", habitId),\n                        where(\"userId\", \"==\", userId),\n                    );\n                    const completionsSnapshot = await getDocs(completionsQuery);\n\n                    // Transform completions and sort by date\n                    const completions = completionsSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .sort(\n                            (a, b) => a.completedAt.toMillis() - b.completedAt.toMillis(),\n                        );\n\n                    // Calculate streak from completions\n                    const calculatedStreak = this.calculateStreakFromCompletions(\n                        completions,\n                        habitId,\n                        userId,\n                    );\n\n                    // Merge with existing data if available\n                    let existingStreak: HabitStreak | null = null;\n                    if (streakDoc.exists()) {\n                        existingStreak = transformFirestoreToStreak(streakDoc.data());\n                    }\n\n                    const updatedStreak = this.mergeStreakData(\n                        calculatedStreak,\n                        existingStreak,\n                    );\n\n                    // Save updated streak\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return updatedStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to calculate streak: ${message}`);\n        }\n    }\n\n    /**\n     * Record a new habit completion and update streak\n     * Requirements: 5.1, 12.1\n     */\n    async recordCompletion(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<HabitCompletion> {\n        if (!completion.habitId || !completion.userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        // Validate timezone-aware completion\n        const userTimezone = completion.timezone || getUserTimezone();\n        const completionDateString = timestampToDateString(\n            completion.completedAt,\n            userTimezone,\n        );\n        const currentDateString = getCurrentDateString(userTimezone);\n\n        // Ensure completion is for current day or earlier (prevent future completions)\n        if (completionDateString > currentDateString) {\n            throw new Error(\"Cannot record completions for future dates\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    // Check for existing completion on the same date\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const existingCompletionsQuery = query(\n                        completionsCollection,\n                        where(\"habitId\", \"==\", completion.habitId),\n                        where(\"userId\", \"==\", completion.userId),\n                    );\n                    const existingSnapshot = await getDocs(existingCompletionsQuery);\n\n                    const existingCompletions = existingSnapshot.docs\n                        .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                        .filter((comp) => {\n                            const compDateString = timestampToDateString(\n                                comp.completedAt,\n                                userTimezone,\n                            );\n                            return compDateString === completionDateString;\n                        });\n\n                    if (existingCompletions.length > 0) {\n                        throw new Error(\"Habit already completed for this date\");\n                    }\n\n                    // Create completion record with metadata\n                    const completionData = {\n                        habitId: completion.habitId,\n                        userId: completion.userId,\n                        completedAt: completion.completedAt,\n                        timezone: userTimezone,\n                        notes: completion.notes || \"\",\n                        difficulty: completion.difficulty,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, completionData);\n\n                    const newCompletion: HabitCompletion = {\n                        id: completionRef.id,\n                        ...completion,\n                        timezone: userTimezone,\n                    };\n\n                    return newCompletion;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to record completion: ${message}`);\n        }\n    }\n\n    /**\n     * Record completion and check for milestone achievements\n     * This is the main method that should be called when a user completes a habit\n     * Requirements: 3.1, 3.2, 5.1\n     */\n    async recordCompletionWithMilestoneCheck(\n        completion: Omit<HabitCompletion, \"id\">,\n    ): Promise<{\n        completion: HabitCompletion;\n        newMilestones: StreakMilestone[];\n        updatedStreak: HabitStreak;\n    }> {\n        // Record the completion\n        const recordedCompletion = await this.recordCompletion(completion);\n\n        // Recalculate streak with the new completion\n        const updatedStreak = await this.calculateStreak(\n            completion.habitId,\n            completion.userId,\n        );\n\n        // Check for new milestones\n        const newMilestones = await this.checkMilestones(updatedStreak);\n\n        return {\n            completion: recordedCompletion,\n            newMilestones,\n            updatedStreak,\n        };\n    }\n\n    /**\n     * Use a streak freeze to protect from a missed day\n     * Requirements: 4.1, 4.2, 4.5\n     */\n    async useStreakFreeze(\n        habitId: string,\n        userId: string,\n        missedDate: string,\n    ): Promise<boolean> {\n        if (!habitId || !userId || !missedDate) {\n            throw new Error(\"Habit ID, User ID, and missed date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    // Check if freeze is available\n                    if (streak.freezesAvailable <= 0) {\n                        return false;\n                    }\n\n                    // Use the freeze\n                    const updatedStreak: HabitStreak = {\n                        ...streak,\n                        freezesAvailable: streak.freezesAvailable - 1,\n                        freezesUsed: streak.freezesUsed + 1,\n                    };\n\n                    // Create a \"protected\" completion record for the missed date\n                    const protectedCompletion = {\n                        habitId,\n                        userId,\n                        completedAt: Timestamp.fromDate(parseDateString(missedDate)),\n                        timezone: getUserTimezone(),\n                        notes: \"Protected by streak freeze\",\n                        difficulty: \"easy\" as const,\n                        createdAt: serverTimestamp(),\n                    };\n\n                    const completionsCollection = getHabitCompletionsCollection();\n                    const completionRef = doc(completionsCollection);\n                    transaction.set(completionRef, protectedCompletion);\n\n                    // Update streak data\n                    const streakData = transformStreakToFirestore(updatedStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return true;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to use streak freeze: ${message}`);\n        }\n    }\n\n    /**\n     * Get calendar data for a habit showing completion status\n     * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5\n     */\n    async getHabitCalendar(\n        habitId: string,\n        userId: string,\n        days: number,\n        timezone: string,\n    ): Promise<CalendarDay[]> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                // Get date range for calendar\n                const endDate = getCurrentDateString(timezone);\n                const startDate = formatDateToString(\n                    new Date(Date.now() - (days - 1) * 24 * 60 * 60 * 1000),\n                    timezone,\n                );\n\n                // Get completions for the date range\n                const completionsCollection = getHabitCompletionsCollection();\n                const completionsQuery = query(\n                    completionsCollection,\n                    where(\"habitId\", \"==\", habitId),\n                    where(\"userId\", \"==\", userId),\n                );\n                const completionsSnapshot = await getDocs(completionsQuery);\n\n                const completions = completionsSnapshot.docs\n                    .map((doc) => transformFirestoreToCompletion(doc.id, doc.data()))\n                    .filter((completion) => {\n                        const compDateString = timestampToDateString(\n                            completion.completedAt,\n                            timezone,\n                        );\n                        return compDateString >= startDate && compDateString <= endDate;\n                    });\n\n                // Get streak data for highlighting\n                const streak = await this.getHabitStreak(habitId, userId);\n\n                // Generate calendar days\n                const dateRange = generateDateRange(startDate, endDate);\n                const calendarDays: CalendarDay[] = dateRange.map((date) => {\n                    const completion = completions.find(\n                        (comp) =>\n                            timestampToDateString(comp.completedAt, timezone) === date,\n                    );\n\n                    const isInStreak = this.isDateInCurrentStreak(date, streak);\n\n                    return {\n                        date,\n                        completed: !!completion,\n                        isToday: isToday(date, timezone),\n                        isInStreak,\n                        completionTime: completion\n                            ? completion.completedAt.toDate().toLocaleTimeString()\n                            : undefined,\n                        notes: completion?.notes,\n                    };\n                });\n\n                return calendarDays;\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit calendar: ${message}`);\n        }\n    }\n\n    /**\n     * Check for new milestones and return any that should be celebrated\n     * Requirements: 3.1, 3.2, 4.4\n     */\n    async checkMilestones(streak: HabitStreak): Promise<StreakMilestone[]> {\n        const newMilestones: StreakMilestone[] = [];\n        const existingMilestoneDays = streak.milestones.map((m) => m.days);\n\n        for (const milestoneDay of MILESTONE_DAYS) {\n            if (\n                streak.currentStreak >= milestoneDay &&\n                !existingMilestoneDays.includes(milestoneDay)\n            ) {\n                const milestone: StreakMilestone = {\n                    days: milestoneDay,\n                    achievedAt: Timestamp.now(),\n                    celebrated: false,\n                };\n                newMilestones.push(milestone);\n\n                // Award streak freeze for 30-day milestones (Requirement 4.4)\n                if (milestoneDay === 30) {\n                    streak.freezesAvailable += 1;\n                }\n            }\n        }\n\n        // Update streak with new milestones\n        if (newMilestones.length > 0) {\n            const updatedStreak: HabitStreak = {\n                ...streak,\n                milestones: [...streak.milestones, ...newMilestones],\n                // Update freezes if 30-day milestone was achieved\n                freezesAvailable: streak.freezesAvailable,\n            };\n\n            const streakId = generateStreakId(streak.userId, streak.habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(updatedStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n        }\n\n        return newMilestones;\n    }\n\n    /**\n     * Get streak information for a specific habit\n     */\n    async getHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak | null> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakDoc = await getDoc(streakDocRef);\n\n            if (!streakDoc.exists()) {\n                return null;\n            }\n\n            const streakData = streakDoc.data();\n            if (!validateStreakDocument(streakData)) {\n                throw new Error(\"Invalid streak data format\");\n            }\n\n            return transformFirestoreToStreak(streakData);\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to get habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Initialize streak data for a new habit\n     */\n    async initializeHabitStreak(\n        habitId: string,\n        userId: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId) {\n            throw new Error(\"Habit ID and User ID are required\");\n        }\n\n        const currentDate = getCurrentDateString(getUserTimezone());\n        const initialStreak: HabitStreak = {\n            habitId,\n            userId,\n            currentStreak: 0,\n            bestStreak: 0,\n            lastCompletionDate: \"\",\n            streakStartDate: currentDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n\n        try {\n            const streakId = generateStreakId(userId, habitId);\n            const streaksCollection = getHabitStreaksCollection();\n            const streakDocRef = doc(streaksCollection, streakId);\n            const streakData = transformStreakToFirestore(initialStreak);\n\n            await runTransaction(db, async (transaction) => {\n                transaction.set(streakDocRef, streakData);\n            });\n\n            return initialStreak;\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to initialize habit streak: ${message}`);\n        }\n    }\n\n    /**\n     * Reset a streak (used when streak is broken and no freeze available)\n     * Requirements: 1.2\n     */\n    async resetStreak(\n        habitId: string,\n        userId: string,\n        resetDate: string,\n    ): Promise<HabitStreak> {\n        if (!habitId || !userId || !resetDate) {\n            throw new Error(\"Habit ID, User ID, and reset date are required\");\n        }\n\n        try {\n            return await retryWithBackoff(async () => {\n                return await runTransaction(db, async (transaction) => {\n                    const streakId = generateStreakId(userId, habitId);\n                    const streaksCollection = getHabitStreaksCollection();\n                    const streakDocRef = doc(streaksCollection, streakId);\n                    const streakDoc = await transaction.get(streakDocRef);\n\n                    if (!streakDoc.exists()) {\n                        throw new Error(\"Streak data not found\");\n                    }\n\n                    const streak = transformFirestoreToStreak(streakDoc.data());\n\n                    // Validate user ownership\n                    if (!validateUserOwnership(userId, streak.userId)) {\n                        throw new Error(\"Unauthorized access to streak data\");\n                    }\n\n                    const resetStreak: HabitStreak = {\n                        ...streak,\n                        currentStreak: 0,\n                        lastCompletionDate: \"\",\n                        streakStartDate: resetDate,\n                    };\n\n                    const streakData = transformStreakToFirestore(resetStreak);\n                    transaction.set(streakDocRef, streakData);\n\n                    return resetStreak;\n                });\n            });\n        } catch (error) {\n            const message = getUserFriendlyErrorMessage(error);\n            throw new Error(`Failed to reset streak: ${message}`);\n        }\n    }\n\n    // Private helper methods\n\n    /**\n     * Calculate streak from completion records\n     */\n    private calculateStreakFromCompletions(\n        completions: HabitCompletion[],\n        habitId: string,\n        userId: string,\n    ): HabitStreak {\n        if (completions.length === 0) {\n            return {\n                habitId,\n                userId,\n                currentStreak: 0,\n                bestStreak: 0,\n                lastCompletionDate: \"\",\n                streakStartDate: getCurrentDateString(getUserTimezone()),\n                freezesAvailable: 0,\n                freezesUsed: 0,\n                milestones: [],\n            };\n        }\n\n        const timezone = completions[0]?.timezone || getUserTimezone();\n        const completionDates = completions.map((comp) =>\n            timestampToDateString(comp.completedAt, timezone),\n        );\n\n        // Remove duplicates and sort\n        const uniqueDates = Array.from(new Set(completionDates)).sort();\n\n        // Calculate current streak (from most recent completion backwards)\n        let currentStreak = 0;\n        let streakStartDate = \"\";\n        const today = getCurrentDateString(timezone);\n        const yesterday = formatDateToString(\n            new Date(Date.now() - 24 * 60 * 60 * 1000),\n            timezone,\n        );\n\n        // Check if there's a completion today or yesterday to start counting\n        const lastCompletionDate = uniqueDates[uniqueDates.length - 1];\n        if (lastCompletionDate === today || lastCompletionDate === yesterday) {\n            currentStreak = 1;\n            streakStartDate = lastCompletionDate;\n\n            // Count backwards for consecutive days\n            for (let i = uniqueDates.length - 2; i >= 0; i--) {\n                const currentDate = uniqueDates[i + 1];\n                const previousDate = uniqueDates[i];\n\n                if (areConsecutiveDays(previousDate, currentDate)) {\n                    currentStreak++;\n                    streakStartDate = previousDate;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Calculate best streak (longest consecutive sequence)\n        let bestStreak = 0;\n        let tempStreak = 1;\n\n        for (let i = 1; i < uniqueDates.length; i++) {\n            if (areConsecutiveDays(uniqueDates[i - 1], uniqueDates[i])) {\n                tempStreak++;\n            } else {\n                bestStreak = Math.max(bestStreak, tempStreak);\n                tempStreak = 1;\n            }\n        }\n        bestStreak = Math.max(bestStreak, tempStreak, currentStreak);\n\n        return {\n            habitId,\n            userId,\n            currentStreak,\n            bestStreak,\n            lastCompletionDate,\n            streakStartDate,\n            freezesAvailable: 0,\n            freezesUsed: 0,\n            milestones: [],\n        };\n    }\n\n    /**\n     * Merge calculated streak with existing streak data\n     */\n    private mergeStreakData(\n        calculated: HabitStreak,\n        existing: HabitStreak | null,\n    ): HabitStreak {\n        if (!existing) {\n            return calculated;\n        }\n\n        return {\n            ...calculated,\n            freezesAvailable: existing.freezesAvailable,\n            freezesUsed: existing.freezesUsed,\n            milestones: existing.milestones,\n            // Ensure best streak never decreases\n            bestStreak: Math.max(calculated.bestStreak, existing.bestStreak),\n        };\n    }\n\n    /**\n     * Check if a date is within the current streak period\n     */\n    private isDateInCurrentStreak(\n        date: string,\n        streak: HabitStreak | null,\n    ): boolean {\n        if (!streak || streak.currentStreak === 0 || !streak.streakStartDate) {\n            return false;\n        }\n\n        const streakStart = parseDateString(streak.streakStartDate);\n        const checkDate = parseDateString(date);\n        const streakEnd = new Date(streakStart);\n        streakEnd.setDate(streakEnd.getDate() + streak.currentStreak - 1);\n\n        return checkDate >= streakStart && checkDate <= streakEnd;\n    }\n}\n\n// Export singleton instance\nexport const streakService = new StreakService();\n"],"mappings":"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","ignoreList":[]}